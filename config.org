#+title: Irkalla Emacs
#+author: Icy-Thought
#+language: en

#+NAME: fig:Irkalla Emacs
#+CAPTION: Irkalla Emacs displayed with the [[https://github.com/catppuccin/catppuccin][Catppuccin]] colorscheme.
[[.github/assets/themes/catppuccin/irkalla.png]]

* Table Of Contents :TOC:
- [[#early-initialization-of-irkalla][Early Initialization of Irkalla]]
  - [[#part-1-defining-the-boundaries-of-irkalla][Part 1: Defining The Boundaries Of Irkalla]]
    - [[#laying-the-foundations-of-irkalla][Laying The Foundations Of Irkalla]]
    - [[#setting-our-ui-changes-early][Setting our UI Changes Early]]
    - [[#maintaining-harmony-within-irkallas-directories][Maintaining Harmony Within Irkalla's Directories]]
  - [[#part-2-performance-enhancements][Part 2: Performance Enhancements]]
    - [[#increase-the-cpu-processing-restrictions][Increase the CPU processing restrictions]]
    - [[#native-comp---quicker-emacs-byte-compile][Native-Comp -> Quicker Emacs (Byte-Compile)]]
    - [[#collect-the-ever-growing-garbage][Collect The Ever-Growing Garbage...]]
  - [[#part-3-setting-our-ever-growing-options][Part 3: Setting Our Ever-Growing Options]]
    - [[#debugging--error-handling][Debugging & Error Handling]]
    - [[#user-interface--startup][User Interface & Startup]]
    - [[#display--fonts][Display & Fonts]]
    - [[#file-handling--version-control][File Handling & Version Control]]
    - [[#miscellaneous][Miscellaneous]]
  - [[#part-4-bidding-our-early-initel-farewell][Part 4: Bidding our =early-init.el= Farewell]]
- [[#core-configurations][Core Configuration(s)]]
  - [[#part-1-beginning-of-a-journey][Part 1: Beginning Of A Journey]]
    - [[#elpaca-package-manager][Elpaca: Package Manager]]
    - [[#functions--macros-to-ameliorate-irkalla][Functions & Macros To Ameliorate Irkalla]]
    - [[#controlling-littering-habits][Controlling Littering Habits]]
    - [[#hydra-windows-that-contain-our-keybindings][Hydra: Windows That Contain Our Keybindings]]
    - [[#managing-the-ever-growing-frames][Managing The Ever-growing Frame(s)]]
    - [[#maintaining-a-sane-scroll-pattern][Maintaining A Sane Scroll Pattern]]
    - [[#24-hour-time-format--other-formats][24-Hour Time Format >> Other Formats]]
  - [[#part-2-decorating-irkalla][Part 2: Decorating Irkalla]]
    - [[#autothemer-macros-to-ease-the-theming-process][Autothemer: Macros To Ease The Theming Process]]
    - [[#prettified-symbols][Prettified Symbols]]
    - [[#typefaces--saner-fonts][Typeface's & Saner Fonts]]
    - [[#adding-a-sprinkle-of-icons][Adding A Sprinkle Of Icons]]
    - [[#svg-tag-decorating-buffers-with-svg][SVG-Tag: Decorating Buffers With SVG]]
    - [[#modelines---status-bars-for-emacs][Modeline(s) -> Status-Bar(s) For Emacs]]
    - [[#tab-bars---a-header-line-for-buffers][Tab Bar(s) -> A Header-Line For Buffers]]
    - [[#dashboard-a-welcoming-buffer-for-new-frames][Dashboard: A Welcoming Buffer For New Frames]]
  - [[#part-3-expanding-the-utility-box][Part 3: Expanding The Utility Box]]
    - [[#introducing-the-basics][Introducing The Basics]]
    - [[#new--extension-of-built-in-features][New & Extension Of Built-in Features]]
    - [[#trivial-changes-to-extend-workflow][Trivial Changes To Extend Workflow]]
  - [[#part-4-editing-environment][Part 4: Editing Environment]]
    - [[#alternative-editing-bindings][Alternative Editing Bindings]]
    - [[#the-basic-requirements-of-an-editor][The Basic Requirements Of An Editor]]
    - [[#expanding-on-the-basic-requirements][Expanding On The Basic Requirements]]
  - [[#part-5-completion--debugging][Part 5: Completion & Debugging]]
    - [[#orderless-completion-candidate-matching][Orderless: Completion Candidate Matching]]
    - [[#breadcrumb-location-indicator-for-larger-projects][Breadcrumb: Location Indicator For Larger Projects]]
    - [[#apheleia-code-formatter][Apheleia: Code Formatter]]
    - [[#corfu-elegant-completion-ui][Corfu: Elegant Completion UI]]
    - [[#cape-controlling-suggestion-output][Cape: Controlling Suggestion Output]]
    - [[#tempel-snippet-completion][Tempel: Snippet Completion]]
    - [[#eldoc-documentation-of-symb][Eldoc: Documentation Of SYMB]]
    - [[#tree-sitter-parser-generator-tool][Tree-Sitter: Parser Generator Tool]]
    - [[#flymake-built-in-buffer-diagnostics][Flymake: Built-in Buffer Diagnostics]]
    - [[#dape-debug-adapter-protocol][Dape: Debug Adapter Protocol]]
    - [[#leetcode-dashboard-for-code-challenges][Leetcode: Dashboard For Code Challenges]]
    - [[#chatgpt-code-prediction-at-the-cost-of-freedom][ChatGPT: Code Prediction At The Cost Of Freedom]]
  - [[#part-6-language-server-protocols][Part 6: Language Server Protocols]]
    - [[#emacs-lisp-the-mother-tounge-of-emacs][Emacs Lisp: The Mother-Tounge Of Emacs]]
    - [[#guile-yet-another-lisp-variant][Guile: Yet Another Lisp Variant]]
    - [[#org-mode-the-superior-documentation-format][Org-Mode: The Superior Documentation Format]]
    - [[#haskell-purely-functional][Haskell: Purely Functional]]
    - [[#kotlin-language-of-dem-android][Kotlin: Language of Dem Android]]
    - [[#lua-embedded-scripting-language][Lua: Embedded Scripting Language]]
    - [[#markdown-minimal-markup-language][Markdown: Minimal Markup Language]]
    - [[#nix-purely-functional-dsl][Nix: Purely Functional DSL]]
    - [[#python-high-level-language][Python: High Level Language]]
    - [[#rust-statically--strongly-typed][Rust: Statically & Strongly Typed]]
    - [[#typst-a-more-powerful-latex-alt][Typst: A More Powerful LaTeX Alt.]]
    - [[#zig-imperative--statically-compiled][Zig: Imperative & Statically Compiled]]
  - [[#part-6-concluding-our-endless-package-hunt][Part 6: Concluding Our Endless Package Hunt!]]

* Early Initialization of Irkalla
:PROPERTIES:
:HEADER-ARGS: :tangle ~/.config/emacs/early-init.el
:END:

#+begin_src emacs-lisp
;;; early-init.el --- Welcome To Irkalla Emacs -*- lexical-binding: t; -*-

;; Copyright (C) 2023-2023 Icy-Thought

;; Author: Icy-Thought <icy-thought@pm.me>
;; Keywords: internal
;; URL: https://icy-thought.github.io/

;;; Commentary:
;; Configurations which ought to be loaded during Irkalla Emacs early initliazation process.

;;; Code:
#+end_src

** Part 1: Defining The Boundaries Of Irkalla

*** Laying The Foundations Of Irkalla

#+begin_src emacs-lisp
(defgroup ikralla nil
  "Irkalla might as well become a cult at this point."
  :link '(url-link "https://github.com/Icy-Thought/emacs.d")
  :group 'emacs)
#+end_src

#+begin_src emacs-lisp
(defcustom irkalla/main-residence (file-truename "~/Workspace/public/emacs.d")
  "The directory where Irkalla resides in."
  :type 'string
  :group 'irkalla)
#+end_src

**** Check: Nix OR Guix Distribution?

#+begin_src emacs-lisp
(defconst IS-REPRO (and (eq system-type 'gnu/linux)
                        (with-temp-buffer
                          (insert-file-contents "/etc/os-release")
                          (re-search-forward "ID=\\(?:nixos\\|guix\\)" nil t))))
#+end_src

*** Setting our UI Changes Early

#+begin_src emacs-lisp
(setq default-frame-alist
      (append (list
               '(alpha-background     . 85)
               '(fullscreen           . nil)
               '(menu-bar-lines       . 0)
               '(tool-bar-lines       . 0)
               '(vertical-scroll-bars . nil)))
      initial-frame-alist (copy-alist default-frame-alist)
      user-emacs-directory "~/.config/emacs")
#+end_src

*** Maintaining Harmony Within Irkalla's Directories

#+begin_src emacs-lisp
#+end_src

**** Appending Directories To Load-Path

**** Move =custom.el= To The =./etc= Directory

#+begin_src emacs-lisp
(setq custom-file
      (expand-file-name "etc/custom.el" user-emacs-directory))

(if (file-exists-p custom-file)
    (load custom-file 'noerror 'nomessage)
  (with-temp-buffer (write-file custom-file)))
#+end_src

**** Prevent Certain Buffers From Being Closed

#+begin_src emacs-lisp
(with-current-buffer "*scratch*"  (emacs-lock-mode 'kill))
(with-current-buffer "*Messages*" (emacs-lock-mode 'kill))
#+end_src

** Part 2: Performance Enhancements

*** Increase the CPU processing restrictions

#+begin_src emacs-lisp
(when (boundp 'read-process-output-max)
  (setq process-adaptive-read-buffering nil
        read-process-output-max (* 24 1024 1024)))
#+end_src

*** Native-Comp -> Quicker Emacs (Byte-Compile)

#+begin_src emacs-lisp
(when (featurep 'native-compile)
  ;; :NOTE| Retain native compilation cache files in ~/.cache/emacs directory
  (let ((path (expand-file-name "var/eln-cache/" user-emacs-directory)))
    (setq native-comp-eln-load-path (list path)
          native-compile-target-directory path))

  ;; :NOTE| Prevent unwanted runtime builds + reduce noise
  (setq native-comp-deferred-compilation nil
        native-comp-async-report-warnings-errors nil))
#+end_src

*** Collect The Ever-Growing Garbage...

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum ; 2^61 bytes
      gc-cons-percentage 0.6)
#+end_src

** Part 3: Setting Our Ever-Growing Options

*** Debugging & Error Handling

#+begin_src emacs-lisp
(setq ad-redefinition-action 'accept
      debug-on-error init-file-debug
      jka-compr-verbose init-file-debug)
#+end_src

*** User Interface & Startup

#+begin_src emacs-lisp
(setq auto-mode-case-fold nil
      blink-cursor-mode nil
      echo-keystrokes 0.02
      fast-but-imprecise-scrolling t
      inhibit-splash-screen t
      inhibit-startup-buffer-menu t
      inhibit-startup-echo-area-message user-login-name
      inhibit-startup-message t
      inhibit-startup-screen t
      use-dialog-box nil
      use-file-dialog nil)
#+end_src

*** Display & Fonts

#+begin_src emacs-lisp
(setq frame-inhibit-implied-resize t
      frame-resize-pixelwise t
      idle-update-delay 1.0
      inhibit-compacting-font-caches t
      redisplay-skip-fontification-on-input t)
#+end_src

*** File Handling & Version Control

#+begin_src emacs-lisp
(setq auto-save-list-file-prefix nil
      create-lockfiles nil
      package-enable-at-startup nil
      use-short-answers t
      vc-follow-symlinks t)
#+end_src

*** Miscellaneous

#+begin_src emacs-lisp
(setq initial-major-mode 'fundamental-mode
      initial-scratch-message nil
      select-enable-clipboard nil
      command-line-x-option-alist nil
      default-input-method nil
      ring-bell-function 'ignore
      select-active-regions 'only
      load-prefer-newer noninteractive)
#+end_src

We might as well set our default Emacs environment to ~UTF-8~.

#+begin_src emacs-lisp
(set-default-coding-systems 'utf-8)
#+end_src

** Part 4: Bidding our =early-init.el= Farewell

#+begin_src emacs-lisp
;;; early-init.el ends here
#+end_src

* Core Configuration(s)
:PROPERTIES:
:HEADER-ARGS: :tangle ~/.config/emacs/init.el
:END:

#+begin_src emacs-lisp
;;; init.el --- Core: laboratory of Irkalla -*- lexical-binding: t; -*-

;; Copyright (C) 2023-2023 Icy-Thought

;; Author: Icy-Thought <icy-thought@pm.me>
;; Keywords: internal
;; URL: https://icy-thought.github.io/

;;; Commentary:
;; The main file where I include my (increasing?) Emacs modules & configurations.

;;; Code:
#+end_src


** Part 1: Beginning Of A Journey
*** Elpaca: Package Manager

**** Informing Elpaca About Irkalla's Build Time

Since Elpaca struggles to find the development build version of my Emacs, it is necessary for me to define the ~elpaca-core-date~ for it to function as intended. The reason for this is because Nix disables the ~emacs-build-time~ for the reproducible builds to work as designed.

#+begin_src emacs-lisp
(unless (<= emacs-major-version 29)
  (defvar elpaca-core-date (list (string-to-number (format-time-string "%Y%m%d")))))
#+end_src

**** Bootstrapping Elpaca

#+begin_src emacs-lisp
(defvar elpaca-installer-version 0.7)
(defvar elpaca-directory (expand-file-name "var/elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                 ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                 ,@(when-let ((depth (plist-get order :depth)))
                                                     (list (format "--depth=%d" depth) "--no-single-branch"))
                                                 ,(plist-get order :repo) ,repo))))
                 ((zerop (call-process "git" nil buffer t "checkout"
                                       (or (plist-get order :ref) "--"))))
                 (emacs (concat invocation-directory invocation-name))
                 ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                       "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                 ((require 'elpaca))
                 ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
#+end_src

Tell =Evil= to refrain from taking over the keybindings when inside ~elpaca-ui-mode~.

#+begin_src emacs-lisp
(with-eval-after-load 'evil
  (evil-make-intercept-map elpaca-ui-mode-map))
#+end_src

**** Integrating =Use-Package= With =Elpaca=

#+begin_src emacs-lisp
(elpaca elpaca-use-package
  (elpaca-use-package-mode)
  (setq use-package-always-ensure t
        use-package-compute-statistics t))
#+end_src

Another neat thing that I could do with the help of macros, is to add a ~use-feature~ macro that helps reduce the burden of writing ~use-package~ + ~:ensure nil~ and instead compress it into ~(use-feature)~!

#+begin_src emacs-lisp
(defmacro use-feature (name &rest args)
  "Similar to `use-package', but for built-in packages.
  NAME and ARGS are in `use-package'."
  (declare (indent defun))
  `(use-package ,name
     :ensure nil
     ,@args))
#+end_src

**** Allow Elpaca To Process The Changes

#+begin_src emacs-lisp
(elpaca-wait)
#+end_src

*** Functions & Macros To Ameliorate Irkalla

**** Permit Irkalla To Read Secrets? (ðŸ¤«)

#+begin_src emacs-lisp
(defun irkalla/read-secret-file (filename)
  "Fetch content of secrets file generated by agenix."
  (with-temp-buffer
    (insert-file-contents (concat "/run/agenix/" filename))
    (string-trim-right (buffer-string))))
#+end_src

*** Controlling Littering Habits

**** Automated Garbage Collection

Allowing ~gcmh~ to control Irkalla's garbage collector does have a noticeable performance increase and should therefore be added to its configuration.

#+begin_src emacs-lisp
(use-package gcmh
  :config (gcmh-mode t)
  :custom
  (gcmh-idle-delay 'auto)
  (gcmh-auto-idle-delay-factor 10)
  (gcmh-high-cons-threshold (* 16 1024 1024)))
#+end_src

**** Careful Placement Of Litter Files

#+begin_src emacs-lisp
(use-package no-littering
  :config
  (setq no-littering-etc-directory (expand-file-name "etc/" user-emacs-directory)
        no-littering-var-directory (expand-file-name "var/" user-emacs-directory))

  (with-eval-after-load 'recentf
    (add-to-list 'recentf-exclude no-littering-etc-directory)
    (add-to-list 'recentf-exclude no-littering-var-directory))

  (with-eval-after-load 'files
    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))
          backup-directory-alist
          `((".*" . ,(no-littering-expand-var-file-name "backups/"))))))
#+end_src

*** Hydra: Windows That Contain Our Keybindings

#+begin_src emacs-lisp
(use-package pretty-hydra
  :config
  (cl-defun pretty-hydra-title (title &optional icon-type icon-name
                                      &key face height v-adjust)
    (let ((face (or face `(:inherit hydra-face-pink :height 1.2 :slant italic)))
          (height (or height 1.2))
          (v-adjust (or v-adjust 0.0)))
      (concat
       (when (and (display-graphic-p) icon-type icon-name)
         (let ((f (intern (format "nerd-icons-%s" icon-type))))
           (when (fboundp f)
             (concat (apply f (list icon-name :face face :height height :v-adjust v-adjust))
                     "  "))))
       (propertize title 'face face)))))
#+end_src

To prevent Elpaca from complaining about the missing ~:prett-hydra~ use-package keyword, we have to tell it to first wait and then proceed with the remaining configuration.

#+begin_src emacs-lisp
(elpaca-wait)
#+end_src

**** Allow Hydras To Float Mid-Air

#+begin_src emacs-lisp
(use-package hydra-posframe
  :ensure (:host github :repo "Ladicle/hydra-posframe")
  :config (hydra-posframe-mode t)
  :custom
  (hydra-posframe-border-width 2)
  (hydra-posframe-parameters '((left-fringe . 25) (right-fringe . 25))))
#+end_src

**** Defining Essential Hydras Early

***** Introducing The Main Hydras

#+begin_src emacs-lisp
(pretty-hydra-define main-hydra
  (:title (pretty-hydra-title "â”€â”€ï½¢ Phylum Cnidaria ï½£â”€â”€" 'mdicon "nf-md-graph")
          :color teal :quit-key "q")
  ("Main"
   (("o" launcher-hydra/body "Launcher")
    ("m" elpaca-hydra/body "Elpaca"))
   "Control"
   (("b" buffer-hydra/body "Buffer"))
   "Action"
   (("z" zone "Zooning out..."))))

(with-eval-after-load 'evil
  (evil-global-set-key 'normal (kbd "SPC") 'main-hydra/body))

(with-eval-after-load 'meow
  (meow-normal-define-key '("S-SPC" . main-hydra/body)))

#+end_src

Then we have another essential Hydra that we will tie our editing related commands to, ~editor-hydra~.

#+begin_src emacs-lisp
(pretty-hydra-define editor-hydra
  (:title (pretty-hydra-title "â”€â”€ï½¢ Chrysaora Melanaster ï½£â”€â”€" 'mdicon "nf-md-graph_outline")
          :color teal :quit-key "q")
  ("Programming"
   (("RET" (if (derived-mode-p 'prog-mode)
               (call-interactively #'compile)
             (message "Buffer /= PROG buffer...")) "Compile"))
   "Action"
   (("b" eval-buffer "Eval Buf."))))

(pretty-hydra-define visual-editor-hydra
  (:title (pretty-hydra-title "â”€â”€ï½¢ (Visual) Chrysaora Melanaster ï½£â”€â”€" 'mdicon "nf-md-graph_outline")
          :color teal :quit-key "q")
  ("Action"
   (("e" eval-region "Eval Region"))))

(with-eval-after-load 'evil
  (evil-global-set-key 'normal (kbd ",") 'editor-hydra/body)
  (evil-global-set-key 'visual (kbd ",") 'visual-editor-hydra/body))

(with-eval-after-load 'meow
  (meow-normal-define-key '("," . editor-hydra/body)))
#+end_src

***** Expanding With Secondary Hydras

****** Buffer(s) Management

#+begin_src emacs-lisp
(pretty-hydra-define buffer-hydra
  (:title (pretty-hydra-title "â”€â”€ï½¢ Main: Buffer(s) ï½£â”€â”€" 'octicon "nf-oct-repo_template")
          :color teal :quit-key "q")
  ("Buffer"
   (("s" scratch-buffer   "Scratch")
    ("j" next-buffer      "Next")
    ("k" previous-buffer  "Previous"))))
#+end_src

****** Creating An Application Launcher

#+begin_src emacs-lisp
(pretty-hydra-define launcher-hydra
  (:title (pretty-hydra-title "â”€â”€ï½¢ Main: Launcher(s) ï½£â”€â”€" 'codicon "nf-cod-rocket")
          :color teal :quit-key "q")
  ("EWW Browse"
   (("w" (eww-browse-url "https://en.wikipedia.org") "Wikipedia"))))
#+end_src

****** Quick Access To Elpaca

#+begin_src emacs-lisp
(with-eval-after-load 'elpaca
  (pretty-hydra-define elpaca-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Main: Elpaca ï½£â”€â”€" 'pomicon "nf-pom-clean_code")
            :color teal :quit-key "q")
    ("Main"
     (("p" elpaca-manager   "Elpaca manager")
      ("r" elpaca-rebuild   "Rebuild package")
      ("i" elpaca-info      "Package info"))
     "Fetch"
     (("f" elpaca-fetch     "Specific package")
      ("e" elpaca-fetch-all "All packages"))
     "Update"
     (("m" elpaca-merge     "Specific package")
      ("a" elpaca-merge-all "All packages")))))
#+end_src

*** Managing The Ever-growing Frame(s)

**** Opaque Frames On Demand

#+begin_src emacs-lisp
(use-feature emacs
  :config
  (defun irkalla/opacify-frame ()
    (let ((alpha-value
           (if (equal (frame-parameter nil 'alpha-background) 100)
               85 100)))
      (set-frame-parameter nil 'alpha-background alpha-value)
      (add-to-list 'default-frame-alist `(alpha-background . ,alpha-value))))

  (define-minor-mode irkalla/opacify-frame-mode
    "Toggle (on/off) Emacs frame transparency on demand!"
    :group 'irkalla
    :global nil
    (irkalla/opacify-frame))
  :custom (window-combination-resize t))
#+end_src

**** Easier Split Windows Navigation

#+begin_src emacs-lisp
(use-feature windmove
  :config
  (windmove-default-keybindings)
  (windmove-default-keybindings 'meta))
#+end_src

**** Winner: Memorize Window Settings

Enabling ~winner-mode~ is necessary if you want to create a "zoom" feature for your Emacs configuration. And by that I mean the ability to zoom into one split window and later zoom out to the previous configuration. But for us to zoom-out, it is required from our Emacs configuration to memorize the previous state and this is where ~winner-mode~ comes in!

#+begin_src emacs-lisp
(use-feature winner
  :config (winner-mode t))
#+end_src

***** Hydra: Window Navigation

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define window-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Base: Frame Management ï½£â”€â”€" 'mdicon "nf-md-dock_window")
            :color teal :quit-key "q")
    ("Main"
     (("o" irkalla/opacify-frame-mode "Opacify Frame" :toggle t))
     "Windows"
     (("f" delete-other-windows "Focus Window")
      ("u" winner-undo          "Restore Old Windows")
      ("r" winner-redo          "Redo Window Change"))))

  (pretty-hydra-define+ main-hydra ()
    ("Control"
     (("w" window-hydra/body "Window")))))
#+end_src

*** Maintaining A Sane Scroll Pattern

#+begin_src emacs-lisp
(use-feature emacs
  :config (pixel-scroll-precision-mode t)
  :custom (scroll-preserve-screen-position t))
#+end_src

*** 24-Hour Time Format >> Other Formats

#+begin_src emacs-lisp
(use-feature time
  :custom
  (display-time-24hr-format t)
  (display-time-day-and-date t))
#+end_src

** Part 2: Decorating Irkalla

*** Autothemer: Macros To Ease The Theming Process

Add the Irkalla theme directory to Emacs ~load-path~. Necessary for [[https://github.com/jasonm23/autothemer][Autothemer]] to recognize my customized themes.

#+begin_src emacs-lisp
(let ((themes-dir (expand-file-name "themes" irkalla/main-residence)))
  (when (file-directory-p themes-dir)
    (add-to-list 'load-path themes-dir)
    (add-to-list 'load-path (expand-file-name "template" themes-dir))))

(add-to-list 'custom-theme-load-path (concat irkalla/main-residence "/themes"))
#+end_src

What remains of us is to load the theme of our choice.

#+begin_src emacs-lisp
(use-package autothemer
  :init (load-theme 'catppuccin-mocha t))
#+end_src

*** Prettified Symbols

#+begin_src emacs-lisp
(use-feature emacs
  :hook (emacs-lisp-mode . prettify-symbols-mode)
  :custom (prettify-symbols-unprettify-at-point 'right-edge))
#+end_src

*** Typeface's & Saner Fonts

**** Fontaine: Macros To Easen The Fontification Process

#+begin_src emacs-lisp
(use-package fontaine
  :demand t
  :hook (kill-emacs . fontaine-store-latest-preset)
  :custom
  (fontaine-presets `((default) ;; <- fallback values
                      (reading
                       :variable-pitch-family "Cardo"
                       :variable-pitch-height 185
                       :variable-pitch-slant normal
                       :variable-pitch-weight regular)
                      (large
                       :default-height 175
                       :default-weight semibold)
                      (t
                       :default-family "VictorMono Nerd Font"
                       :default-height 145
                       :default-weight semibold
                       :italic-weight semibold

                       :fixed-pitch-family nil
                       :fixed-pitch-height 145
                       :fixed-pitch-slant normal
                       :fixed-pitch-weight semibold

                       :variable-pitch-family "VictorMono Nerd Font Mono"
                       :variable-pitch-height 1.00
                       :variable-pitch-slant italic
                       :variable-pitch-weight semibold)))
  :config (fontaine-set-preset (or (fontaine-restore-latest-preset) 'default)))
#+end_src

We also want to create a mode for the ~reading~ preset to activate/deactivate from a Hydra.

#+begin_src emacs-lisp
(defun irkalla/manuscript-toggle ()
  "Toggle buffer appearance for a touch of sophistication."
  (if (eq (symbol-value 'fontaine-current-preset) 'regular)
      (fontaine-set-preset 'reading)
    (fontaine-set-preset 'regular)))

(define-minor-mode irkalla/manuscript-mode
  "Paint our buffers with the ancient manuscript style."
  :group 'irkalla
  :global nil
  (irkalla/manuscript-toggle))
#+end_src

***** Hydra: Append Font Controls

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ window-hydra ()
    ("Main"
     (("t" fontaine-set-preset "Fontaine Preset")
      ("m" irkalla/manuscript-mode "Manuscript Mode" :toggle t)))))
#+end_src

**** Remapping Face's & Adding Text Zoom Feature

Displaying all languages with the same font is cursed and lucky enough Emacs provides a proper way to deal with such cursed behavior! With the help of ~set-fontset-font~ we can inform Emacs about the fonts we'd like it to use when displaying content written in a given language.

#+begin_src emacs-lisp
(use-feature face-remap
  :hook (text-mode . variable-pitch-mode)
  :bind (("C-0" . (lambda () (interactive) (text-scale-increase 0.0)))
         ("C-+" . (lambda () (interactive) (text-scale-increase 0.5)))
         ("C--" . (lambda () (interactive) (text-scale-decrease 0.5))))
  :config
  (set-fontset-font t 'arabic (font-spec :family "Scheherazade New") nil 'prepend)
  (set-fontset-font t 'han    (font-spec :family "Sarasa Mono CL")   nil 'prepend)
  (set-fontset-font t 'symbol (font-spec :family "Noto Color Emoji") nil 'append))
#+end_src

**** Changing The Slants A Bit

#+begin_src emacs-lisp
(use-feature font-lock
  :custom-face
  (font-lock-builtin-face       ((t (:slant italic))))
  (font-lock-comment-face       ((t (:slant italic))))
  (font-lock-doc-face           ((t (:slant italic))))
  (font-lock-function-name-face ((t (:slant italic :weight bold))))
  (font-lock-keyword-face       ((t (:slant italic))))
  (font-lock-preprocessor-face  ((t (:weight bold))))
  (font-lock-string-face        ((t (:slant italic))))
  :custom (font-lock-maximum-decoration t))
#+end_src

*** Adding A Sprinkle Of Icons

#+begin_src emacs-lisp
(use-package nerd-icons
  :custom
  (nerd-icons-font-family
   (when (featurep 'fontaine)
     (plist-get (fontaine--get-preset-properties 'default) :default-family)))
  (nerd-icons-scale-factor 1.05))
#+end_src

We should also be able to complete the icons as we do on other platforms.

#+begin_src emacs-lisp
(use-package nerd-icons-completion
  :config
  (nerd-icons-completion-mode)
  (with-eval-after-load 'marginalia
    (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup)))
#+end_src

*** SVG-Tag: Decorating Buffers With SVG

#+begin_src emacs-lisp
(use-package svg-tag-mode
  :hook ((prog-mode text-mode) . svg-tag-mode)
  :config
  <<svg-tag-constants>>
  <<svg-tag-progress-bar>>
  <<svg-tag-patterns>>)
#+end_src

**** Defining Constants
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+NAME: svg-tag-constants
#+begin_src emacs-lisp
(defconst date-re "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}")
(defconst time-re "[0-9]\\{2\\}:[0-9]\\{2\\}")
(defconst day-re "[A-Za-z]\\{3\\}")
(defconst day-time-re (format "\\(%s\\)? ?\\(%s\\)?" day-re time-re))
#+end_src

**** Adding A Progress Bar
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+NAME: svg-tag-progress-bar
#+begin_src emacs-lisp
(defun svg-progress-percent (value)
  (svg-image (svg-lib-concat
              (svg-lib-progress-bar (/ (string-to-number value) 100.0)
                                    nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
              (svg-lib-tag (concat value "%")
                           nil :stroke 0 :margin 0)) :ascent 'center)

  (defun svg-progress-count (value)
    (let* ((seq (mapcar #'string-to-number (split-string value "/")))
           (count (float (car seq)))
           (total (float (cadr seq))))
      (svg-image (svg-lib-concat
                  (svg-lib-progress-bar (/ count total) nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
                  (svg-lib-tag value nil :stroke 0 :margin 0)) :ascent 'center))))
#+end_src

**** Specifying Tagging Patterns
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+NAME: svg-tag-patterns
#+begin_src emacs-lisp
(setq svg-tag-tags
      `(;; Watever tags we choose shall be materialized!
        <<svg-tagging-general>>
        <<svg-tagging-org-mode>>))
#+end_src

***** SVG Tagging: General

#+NAME: svg-tagging-general
#+begin_src emacs-lisp
;; :TODO| Reduce to a more general solution
;; :NOTE| Reduce to a more general solution
;; :FIXME| There is more regexp
;; :HACK| Fix this regexp
;; :WARN| This needs to be fixed

("\\([:]\\(?:TODO\\|todo\\)|.*\\)" . ((lambda (tag)
                                        (svg-tag-make tag :face 'org-todo :inverse t :crop-left t :beg 6))))

("\\([:]\\(?:TODO\\|todo\\)*|\\)" . ((lambda (tag)
                                       (svg-tag-make tag :face 'org-todo :inverse nil :margin 0 :crop-right t :beg 1 :end -1))))

("\\([:]\\(?:WARN\\|warn\\)|.*\\)" . ((lambda (tag)
                                        (svg-tag-make tag :face 'org-priority :inverse t :crop-left t :beg 7))))

("\\([:]\\(?:FIXME\\|fixme\\)|.*\\)" . ((lambda (tag)
                                          (svg-tag-make tag :face 'org-upcoming-deadline :inverse t :crop-left t :beg 7))))

("\\([:]\\(?:FIXME\\|fixme\\)*|\\)" . ((lambda (tag)
                                         (svg-tag-make tag :face 'org-upcoming-deadline :inverse nil :margin 0 :crop-right t :beg 1 :end -1))))

("\\([:]\\(?:HACK\\|PERF\\|MARK\\|hack\\)|.*\\)" . ((lambda (tag)
                                                      (svg-tag-make tag :face 'org-priority :inverse t :crop-left t :beg 6))))

("\\([:]\\(?:HACK\\|hack\\|PERF\\|WARN\\|warn\\|MARK\\)*|\\)" . ((lambda (tag)
                                                                   (svg-tag-make tag :face 'org-priority :inverse nil :margin 0 :crop-right t :beg 1 :end -1))))

("\\([:]\\(?:NOTE\\|note\\)|.*\\)" . ((lambda (tag)
                                        (svg-tag-make tag :face 'org-quote :inverse t :crop-right t :beg 6))))

("\\([:]\\(?:NOTE\\|note\\)*|\\)" . ((lambda (tag)
                                       (svg-tag-make tag :face 'org-quote :inverse nil :margin 0 :crop-right t :beg 1 :end -1))))
#+end_src

***** SVG Tagging: Org-Mode

#+NAME: svg-tagging-org-mode
#+begin_src emacs-lisp
;; Org tags :THIS:
;; ("\\(:[A-Za-z0-9]+:\\)" . ((lambda (tag)
;;                              (svg-tag-make tag :beg 1 :end -1 :inverse t))))

;; Task priority [#a]
("\\[#[a-zA-Z]\\]" . ((lambda (tag)
                        (svg-tag-make tag :face 'org-priority :beg 2 :end -1 :margin 0 :inverse t))))

;; Progress (percentage): [45%]
("\\(\\[[0-9]\\{1,3\\}%\\]\\)" . ((lambda (tag)
                                    (svg-progress-percent (substring tag 1 -2)))))

;; Progress (fraction): [1/3]
("\\(\\[[0-9]+/[0-9]+\\]\\)" . ((lambda (tag)
                                  (svg-progress-count (substring tag 1 -1)))))

;; Org TAGS
(":TODO:"               . ((lambda (tag) (svg-tag-make "TODO"         :face 'org-todo))))
(":WIP:"                . ((lambda (tag) (svg-tag-make "WIP"          :face 'org-cite))))
(":DONE:"               . ((lambda (tag) (svg-tag-make "DONE"         :face 'org-done))))
(":NOTE:"               . ((lambda (tag) (svg-tag-make "NOTE"))))
("SCHEDULED:"           . ((lambda (tag) (svg-tag-make "SCHEDULED"    :face 'org-warning))))
("DEADLINE:"            . ((lambda (tag) (svg-tag-make "DEADLINE"     :face 'org-priority))))
("^#\\+begin_src"       . ((lambda (tag) (svg-tag-make "BEGIN_SRC"    :face 'org-block-begin-line))))
("^#\\+end_src"         . ((lambda (tag) (svg-tag-make "END_SRC"      :face 'org-block-end-line))))
("^#\\+begin_export"    . ((lambda (tag) (svg-tag-make "BEGIN_EXPORT" :face 'org-block-begin-line))))
("^#\\+end_export"      . ((lambda (tag) (svg-tag-make "END_EXPORT"   :face 'org-block-end-line))))
("^#\\+begin_example"   . ((lambda (tag) (svg-tag-make "EXAMPLE"      :face 'org-block-begin-line))))
("^#\\+end_example"     . ((lambda (tag) (svg-tag-make "EXAMPLE"      :face 'org-block-end-line))))
("^#\\+begin_quote"     . ((lambda (tag) (svg-tag-make "QUOTE"        :face 'org-quote :italic t))))
("^#\\+end_quote"       . ((lambda (tag) (svg-tag-make "QUOTE"        :face 'org-quote :italic t))))
("^#\\+begin_signature" . ((lambda (tag) (svg-tag-make "SIGNATURE"    :face 'org-footnote :italic t))))
("^#\\+end_signature"   . ((lambda (tag) (svg-tag-make "SIGNATURE"    :face 'org-footnote :italic t))))
("^#\\+begin_sidenote"  . ((lambda (tag) (svg-tag-make "SIDENOTE"     :face 'org-quote :italic t))))
("^#\\+end_sidenote"    . ((lambda (tag) (svg-tag-make "SIDENOTE"     :face 'org-quote :italic t))))
("^#\\+RESULTS:"        . ((lambda (tag) (svg-tag-make "RESULTS"      :face 'org-done :underline nil))))
(":X"                   . ((lambda (tag) (svg-tag-make "[X]"          :face 'org-checkbox-statistics-done))))
(":-"                   . ((lambda (tag) (svg-tag-make "[-]"          :face 'org-checkbox))))

;; Citation of the form [cite:@Knuth:1984]
("\\(\\[cite:@[A-Za-z]+:\\)" . ((lambda (tag)
                                  (svg-tag-make tag :inverse t :beg 7 :end -1 :crop-right t))))

("\\[cite:@[A-Za-z]+:\\([0-9]+\\]\\)" . ((lambda (tag)
                                           (svg-tag-make tag :end -1 :crop-left t))))

;;; Works for stuff like :XXX|YYY:
("\\(:[A-Z]+\\)\|[a-zA-Z#0-9]+:" . ((lambda (tag)
                                      (svg-tag-make tag :beg 1 :inverse t :margin 0 :crop-right t))))

(":[A-Z]+\\(\|[a-zA-Z#0-9]+:\\)" . ((lambda (tag)
                                      (svg-tag-make tag :beg 1 :end -1 :margin 0 :crop-left t))))

;; Active date (with or without day name, with or without time) <2023-04-03 Sun 17:45>
(,(format "\\(<%s>\\)" date-re) . ((lambda (tag)
                                     (svg-tag-make tag :beg 1 :end -1 :margin 0))))

(,(format "\\(<%s \\)%s>" date-re day-time-re) . ((lambda (tag)
                                                    (svg-tag-make tag :beg 1 :inverse t :crop-right t :margin 0 :face 'org-agenda-date))))

(,(format "<%s \\(%s>\\)" date-re day-time-re) . ((lambda (tag)
                                                    (svg-tag-make tag :end -1 :inverse nil :crop-left t :margin 0 :face 'org-agenda-date))))
#+end_src

*** Modeline(s) -> Status-Bar(s) For Emacs

**** Doom: A Rather Doomed Modeline

#+begin_src emacs-lisp
(use-package doom-modeline
  :init (doom-modeline-mode t)
  :custom
  (doom-modeline-bar-width 4)
  (doom-modeline-buffer-file-name 'relative-to-project)
  (doom-modeline-github t)
  (doom-modeline-github-interval (* 30 60))
  (doom-modeline-height 35)
  (when (display-graphic-p) (doom-modeline-hud t)))
#+end_src

**** Modifying The Built-in Modeline
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(use-package minions
  :init (minions-mode t))

(use-package moody
  :config
  (moody-replace-mode-line-front-space)
  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode))
#+end_src

*** Tab Bar(s) -> A Header-Line For Buffers

**** Centaur Tabs: A Header Line For Buffers

Reference:
- https://github.com/ema2159/centaur-tabs/issues/127#issuecomment-1848219082

#+begin_src emacs-lisp
(use-package centaur-tabs
  :bind (:map centaur-tabs-mode-map
              ("C-<prior>"   . #'centaur-tabs-backward-group)
              ("C-<next>"    . #'centaur-tabs-forward-group)
              ("M-<prior>"   . #'centaur-tabs-backward)
              ("M-<next>"    . #'centaur-tabs-forward)
              ("M-S-<prior>" . #'centaur-tabs-move-current-tab-to-left)
              ("M-S-<next>"  . #'centaur-tabs-move-current-tab-to-right))
  :init (centaur-tabs-mode t)
  :config
  (setq x-underline-at-descent-line t
        centaur-tabs-set-icons t
        centaur-tabs-cycle-scope 'tabs
        centaur-tabs-enable-key-bindings t
        centaur-tabs-height 32
        centaur-tabs-left-edge-margin nil
        centaur-tabs-set-bar 'under
        centaur-tabs-show-count nil
        centaur-tabs-set-modified-marker t
        centaur-tabs-show-navigation-buttons t
        centaur-tabs-show-new-tab-button t
        centaur-tabs-adjust-buffer-order t)
  (centaur-tabs-enable-buffer-reordering)

  ;; :NOTE| We do not want Centaur-Tabs everywhere, do we?
  (dolist (prefix '("*" " *" ;; all temporary buffers
                    "consult-partial-preview"
                    "Ement"
                    "magit"))
    (add-to-list 'centaur-tabs-excluded-prefixes prefix)))
#+end_src

**** Tabspaces: Buffer Isolated Workspaces
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(use-package tabspaces
  :commands (tabspaces-switch-or-create-workspace
             tabspaces-open-or-create-project-and-workspace)
  :config
  (tabspaces-mode t)
  <<tabspaces-consult-buffers>>
  :custom
  (tabspaces-session t)
  (tabspaces-keymap-prefix "C-c p")
  (tabspaces-default-tab "Default")
  (tabspaces-remove-to-default t)
  (tabspaces-include-buffers '("*scratch*"))
  (tabspaces-initialize-project-with-todo t)
  (tabspaces-todo-file-name "project-todo.org")
  (tabspaces-use-filtered-buffers-as-default t))
#+end_src

We also want consult to be able to track our separated buffers properly and not mix them togheter.

#+NAME: tabspaces-consult-buffers
#+begin_src emacs-lisp :tangle no
(with-eval-after-load 'consult
  (consult-customize consult--source-buffer :hidden t :default nil)
  (defvar consult--source-workspace
    (list :name     "Workspace Buffers"
          :narrow   ?w
          :history  'buffer-name-history
          :category 'buffer
          :state    #'consult--buffer-state
          :default  t
          :items    (lambda ()
                      (consult--buffer-query
                       :predicate #'tabspaces--local-buffer-p
                       :sort 'visibility
                       :as #'buffer-name))))
  (add-to-list 'consult-buffer-sources 'consult--source-workspace))
#+end_src

To ease the navigation between the growing tabs, we could add navigation bindings akin to the once we have for windows in browsers.

#+begin_src emacs-lisp
(use-feature tab-bar
  :bind (("C-<next>" . tab-next)
         ("C-<prior>" . tab-previous))
  :config (tab-bar-mode t)
  :custom
  (tab-bar-show 1)
  (tab-bar-tab-hints t)
  (tab-bar-new-tab-choice "*dashboard*"))
#+end_src

*** Dashboard: A Welcoming Buffer For New Frames

#+begin_src emacs-lisp
(use-package dashboard
  :after (nerd-icons)
  :commands (dashboard-refresh-buffer)
  :hook (dashboard-mode . hl-line-mode)
  :custom-face
  (dashboard-heading           ((t (:weight regular))))
  (dashboard-banner-logo-title ((t (:weight regular))))
  :custom
  (initial-buffer-choice (lambda () (dashboard-refresh-buffer) (get-buffer dashboard-buffer-name)))
  (dashboard-display-icons-p t)
  (dashboard-icon-type 'nerd-icons)
  (dashboard-banner-logo-title "Welcome To The Underworld, Human. - Irkalla")
  (dashboard-center-content t)
  (dashboard-modify-heading-icons '((recents . "file-text") (bookmarks . "book")))
  (dashboard-startup-banner (concat irkalla/main-residence "/logos/owl-skull.svg"))
  (dashboard-path-max-length 20)
  (dashboard-set-heading-icons t)
  (dashboard-set-file-icons t)
  (dashboard-set-init-info t)
  (dashboard-week-agenda t)
  (dashboard-set-navigator t)
  (dashboard-navigator-buttons
   `(((,(nerd-icons-octicon "nf-oct-mark_github" :height 1.2 :v-adjust 0.0)
       "Homepage"
       "Browse my personal GitHub profile home."
       (lambda (&rest _) (browse-url "https://github.com/Icy-Thought")))

      (,(nerd-icons-mdicon "nf-md-download" :height 1.2 :v-adjust 0.0)
       "Elpaca Manager"
       "Manage Irkalla Emacs packages."
       (lambda (&rest _) (elpaca-manager)))

      (,(nerd-icons-mdicon "nf-md-refresh" :height 1.2 :v-adjust 0.0)
       "Restart Emacs.."
       "Restart Irkalla Emacs instance."
       (lambda (&rest _) (restart-emacs))))))

  (dashboard-items '((recents   . 5)
                     (bookmarks . 5)
                     (projects  . 5)
                     (agenda    . 5)
                     (registers . 5)))

  (dashboard-item-names '(("Recent Files:" . "Recently opened files:")
                          ("Agenda for today:" . "Today's agenda:")
                          ("Agenda for the coming week:" . "Agenda:"))))
#+end_src

**** Hydra: Dashboard Launch Option

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ launcher-hydra ()
    ("Application"
     (("RET" dashboard-refresh-buffer "Dashboard")))))
#+end_src

** Part 3: Expanding The Utility Box

*** Introducing The Basics

**** Spawn Emacs Everywhere

#+begin_src emacs-lisp
(use-package emacs-everywhere
  :commands (emacs-everywhere)
  :custom (emacs-everywhere-copy-command (list "cat" "%f" "|" "cb" "copy")))

#+end_src

**** Trace Performance Hiccups

#+begin_src emacs-lisp
(use-package esup
  :commands (esup)
  :custom (esup-depth 0))
#+end_src

**** Helpful: ~C-h~ On Steroids

#+begin_src emacs-lisp
(use-package helpful
  :bind
  ([remap describe-callable]    . helpful-callable)
  ([remap describe-function]    . helpful-function)
  ([remap describe-variable]    . helpful-variable)
  ([remap describe-key]         . helpful-key)
  ([remap view-emacs-debugging] . helpful-at-point)
  :pretty-hydra
  ((:title (pretty-hydra-title "â”€â”€ï½¢ Utilities: Helpful ï½£â”€â”€" 'mdicon "nf-md-help_network")
           :color teal :quit-key "q")
   ("Describe"
    (("k" helpful-key      "Key(s)")
     ("f" helpful-function "Function(s)")
     ("F" helpful-callable "Interactive function(s)")
     ("v" helpful-variable "Variable(s)")
     ("c" helpful-command  "Command(s)"))
    "Action"
    (("p" helpful-at-point "SYMB at point"))))
  :init (setq help-window-select t))
#+end_src

Since we created our Hydra with ~:pretty-hydra~ keyword, we can just append our new hydra to our main Hydra.

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ main-hydra ()
    ("Main"
     (("h" helpful-hydra/body "Helpful")))))
#+end_src

**** Controlling Recent Files

#+begin_src emacs-lisp
(use-feature recentf
  :defer 1
  :custom
  (recentf-save-file-modes #o600)
  (recentf-max-saved-items 1024)
  (recentf-auto-cleanup 600)
  (recentf-exclude '(;; Compressed files & Archives
                     "\\.tar$" "\\.tbz2$" "\\.tbz$" "\\.tgz$"
                     "\\.bz2$" "\\.bz$" "\\.gz$" "\\.gzip$" "\\.xz$" "\\.zpaq$"
                     "\\.lz$" "\\.lrz$" "\\.lzo$" "\\.lzma$" "\\.shar$" "\\.kgb$"
                     "\\.zip$" "\\.Z$" "\\.7z$" "\\.rar$"
                     ;; TRAMP
                     "^/sudo:" "^/ssh:"
                     ;; Emacs-Everywhere
                     "/tmp/emacs-everywhere")))
#+end_src

**** Chinese, Japanese & Korean
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(use-package pyim
  :bind (:map text-mode-map ("M-j" pyim-convert-string-at-point))
  :custom
  (pyim-default-scheme 'quanpin)
  (pyim-page-tooltip 'posframe)
  (pyim-page-length 5)
  (pyim-directory (no-littering-expand-var-file-name "pyim/"))
  (pyim-dcache-directory (pyim-directory "dcache/")))
#+end_src

Also, I want several dictionaries to learn & recall the definitions of several words.

#+begin_src emacs-lisp
(use-package pyim-basedict
  :requires (pyim)
  :hook (pyim-mode . pyim-basedict-enable))

(use-package youdao-dictionary
  :commands (youdao-dictionary-search-at-point-posframe)
  :bind (("C-c y" youdao-dictionary-search-at-point-posframe)))
#+end_src

*** New & Extension Of Built-in Features

**** Popper: Pop-up Related Buffers On Demand

#+begin_src emacs-lisp
(use-package popper
  :preface
  (defun popper-display-vertical-popup (buffer &optional alist)
    (display-buffer-in-side-window
     buffer (append alist `((window-width 0.5) (side . right) (slot . 1)))))

  (defun popper-select-vertical-popup (buffer &optional alist)
    (let ((window (popper-display-vertical-popup buffer alist)))
      (select-window window)))
  :config
  (popper-mode t)
  (popper-echo-mode t)
  :custom
  (popper-group-function #'popper-group-by-directory)
  (popper-display-function #'popper-select-vertical-popup)
  (popper-reference-buffers '(help-mode
                              "\\*Messages\\*"
                              "\\*Async Shell Command\\*"
                              "Output\\*$"
                              "^\\*apheleia.*\\*$"
                              "\\*.*compilation.*\\*"
                              ("*Python*" . hide)
                              ("\\*.*REPL.*\\*" . hide)
                              (compilation-list-mode . hide)

                              ;; :NOTE| terminal-related
                              "^\\*eat.*\\*$"    eat-mode
                              "^\\*eshell.*\\*$" eshell-mode
                              "^\\*shell.*\\*$"  shell-mode
                              "^\\*term.*\\*$"   term-mode
                              "^\\*vterm.*\\*$"  vterm-mode)))
#+end_src

***** Hydra: Adding Popper Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define popper-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Utilities: Popper ï½£â”€â”€" 'mdicon "nf-md-lightbulb_on_outline")
            :color teal :quit-key "q")
    ("Action(s)"
     (("t" popper-toggle      "Un/Toggle Popup")
      ("j" popper-cycle       "Cycle Between Popup(s)")
      ("s" popper-toggle-type "Add Buf. To Popup"))))

  (pretty-hydra-define+ main-hydra ()
    ("Action"
     (("t" popper-hydra/body "Popper")))))
#+end_src

**** Dired: Built-in Emacs File Manager

Being able to drag from/to Emacs is always a pleasurable feeling. Thus I shall add that minor feature to Irkalla.

#+begin_src emacs-lisp
(use-feature dired
  :config
  (setq mouse-drag-and-drop-region-cross-program t
        mouse-1-click-follows-link nil)

  ;; :NOTE| prevent centaur-tabs from displaying inside dired dictionaries
  (when (featurep 'centaur-tabs)
    (add-hook 'dired-mode-hook #'centaur-tabs-local-mode))
  :custom (dired-mouse-drag-files t))
#+end_src

I also would like =Dired= to be able to launch certain file-extensions with certain external programs.

#+begin_src emacs-lisp
(use-feature dired-x
  :after (dired)
  :preface
  (defun dired-external-launch (application extensions)
    "External `APPLICATION' used for launching specific file-extensions."
    (let ((pattern (concat "\\." (regexp-opt extensions t) "$"))
          (entry (list pattern application)))
      (add-to-list 'dired-guess-shell-alist-user entry)))
  :custom
  (dired-external-launch
   (if (eq system-type 'gnu/linux) "mpv" "xdg-open")
   '("avi" "flv" "mkv" "mov" "mp3" "mp4" "mpeg" "mpg" "ogg" "ogm" "wav" "wmv"))

  (dired-external-launch
   (if (eq system-type 'gnu/linux) "libreoffice" "xdg-open")
   '("doc" "docx"  "odt" "xls" "xlsx")))
#+end_src

Lastly, I want the different type of directories to have some form of syntax highlighting.

#+begin_src emacs-lisp
(use-package diredfl
  :after (dired)
  :hook ((dired-mode dirvish-directory-view-mode) . diredfl-mode)
  :custom-face (diredfl-dir-name ((t :bold t))))
#+end_src

***** Dirvish: Polishing Dired + Batteries

#+begin_src emacs-lisp
(use-package dirvish
  :after (dired)
  :bind (([remap dired] . dirvish-side)
         :map dirvish-mode-map
         ("a"   . dirvish-quick-access)
         ("f"   . dirvish-file-info-menu)
         ("y"   . dirvish-yank-menu)
         ("N"   . dirvish-narrow)
         ("^"   . dirvish-history-last)
         ("h"   . dirvish-history-jump)
         ("s"   . dirvish-quicksort)
         ("v"   . dirvish-vc-menu)
         ("TAB" . dirvish-subtree-toggle)
         ("M-f" . dirvish-history-go-forward)
         ("M-b" . dirvish-history-go-backward)
         ("M-l" . dirvish-ls-switches-menu)
         ("M-m" . dirvish-mark-menu)
         ("M-t" . dirvish-layout-toggle)
         ("M-s" . dirvish-setup-menu)
         ("M-e" . dirvish-emerge-menu)
         ("M-j" . dirvish-fd-jump)
         ("<mouse-1>" . dirvish-subtree-toggle-or-open)
         ("<mouse-2>" . dired-mouse-find-file-other-window)
         ("<mouse-3>" . dired-mouse-find-file))
  :config
  (dirvish-override-dired-mode t)
  (dirvish-peek-mode t)
  (dirvish-side-follow-mode t)

  ;; :NOTE| We do not want centaur-tabs to display inside dirvish, do we?
  (when (featurep 'centaur-tabs)
    (add-hook 'dirvish-directory-view-mode #'centaur-tabs-local-mode))
  :custom
  (dirvish-side-width 30)
  (dirvish-use-header-line t)
  (dirvish-use-mode-line nil)
  (dirvish-fd-default-dir "~/")
  (dirvish-quick-access-entries
   '(("h" "~/"                          "Home")
     ("d" "~/Downloads/"                "Downloads")
     ("m" "/mnt/"                       "Drives")
     ("l" "~/Library/unexplored"        "Library")
     ("t" "~/.local/share/Trash/files/" "Rubbish Bin")))
  (dirvish-attributes '(nerd-icons file-time file-size collapse subtree-state vc-state git-msg))
  (dired-listing-switches "-l --almost-all --human-readable --group-directories-first --no-group"))
#+end_src

**** Which Key Was It Again???

#+begin_src emacs-lisp
(use-package which-key
  :diminish which-key-mode
  :config
  (which-key-mode t)
  (which-key-setup-minibuffer)
  :custom
  (which-key-allow-evil-operators t)
  (which-key-idle-delay 0.3)
  (which-key-show-remaining-keys t)
  (which-key-separator " â†’ ")
  (which-key-sort-order 'which-key-prefix-then-key-order))
#+end_src

**** Consult: Search & Navigation Commands

#+begin_src emacs-lisp
(use-package consult
  :hook (completion-list-mode . consult-preview-at-point-mode)
  :config
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Consult -> select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)
  :custom
  (consult-narrow-key "<") ;; "C-+"
  (consult-customize consult-theme :preview-key '(:debounce 0.2 any)
                     consult-ripgrep consult-git-grep consult-grep
                     consult-bookmark consult-recent-file consult-xref
                     consult--source-bookmark consult--source-file-register
                     consult--source-recent-file consult--source-project-recent-file
                     :preview-key '(:debounce 0.4 any)))
#+end_src

Allowing consult to interact with my ever-growing projects is something I consider to be useful.

#+begin_src emacs-lisp
(use-package consult-projectile
  :requires (consult projectile))
#+end_src

***** Hydra: Consult Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define consult-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Utilities: Consult ï½£â”€â”€" 'mdicon "nf-md-console")
            :color teal :quit-key "q")
    ("Main"
     (("f" consult-fd                        "Find files by NAME")
      ("r" consult-recent-file               "Recent files")
      ("s" consult-projectile-switch-project "Switch project")
      ("/" consult-ripgrep                   "Grep <- REGEXP"))
     "Action"
     (("B" consult-bookmark                  "Open named bookmark")
      ("h" consult-history                   "Insert STR from hist.")
      ("p" consult-yank-pop                  "Paste yank <- reg.")
      ("t" consult-theme                     "Switch Theme"))))

  (pretty-hydra-define+ main-hydra ()
    ("Action"
     (("f" consult-hydra/body "Consult"))))

  (pretty-hydra-define editor-consult-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Utilities: Consult ï½£â”€â”€" 'mdicon "nf-md-console")
            :color teal :quit-key "q")
    ("Jump To"
     (("m" consult-mark                      "Marker")
      ("M" consult-global-mark               "Glob. Marker")
      ("o" consult-outline                   "Buffer Outlines")
      ("f" consult-flymake                   "Flymake Diagnostics")
      ("e" consult-compile-error             "Buffer Compile Errors"))))

  (pretty-hydra-define+ editor-hydra ()
    ("Control"
     (("f" editor-consult-hydra/body "Consult"))))

  (pretty-hydra-define+ buffer-hydra ()
    ("Consult"
     (("b" consult-buffer                    "Switch Buffer")
      ("B" consult-projectile-buffer         "Project Buf. Switch")
      ("w" consult-buffer-other-window       "Split Buf. Switch"))))

  (pretty-hydra-define+ helpful-hydra ()
    ("Action"
     (("?" consult-man                       "Consult MAN-page(s)")
      ("i" consult-info                      "Consult MANUAL")))))
#+end_src

**** Embark: Mini-Buffer Actions

#+begin_src emacs-lisp
(use-package embark
  :config
  (setq prefix-help-command #'embark-prefix-help-command)
  ;; :NOTE| Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
  :custom
  (embark-prompter #'embark-completing-read-prompter)
  (embark-indicators '(embark-highlight-indicator embark-isearch-highlight-indicator)))
#+end_src

Well, since =Embark= and =Consult= can be linked... I do not see a reason for their seperation.

#+begin_src emacs-lisp
(use-package embark-consult
  :requires (embark consult)
  :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

***** Hydra: Embark Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define embark-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Utilities: Embark ï½£â”€â”€" 'mdicon "nf-md-lightbulb_on_outline")
            :color teal :quit-key "q")
    ("Action(s)"
     (("a" embark-act      "Prompt -> perform")
      ("d" embark-dwim     "Run default on buffer"))
     "Documentation"
     (("h" embark-bindings "Explore Emacs bindings"))))

  (pretty-hydra-define+ main-hydra ()
    ("Action"
     (("e" embark-hydra/body "Embark")))))
#+end_src

**** Vertico: Mini-Buffer On Steroids

#+begin_src emacs-lisp
(use-package vertico
  :bind (:map vertico-map
              ("RET"   . vertico-directory-enter)
              ("DEL"   . vertico-directory-delete-char)
              ("M-DEL" . vertico-directory-delete-word))
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
  :init (vertico-mode t)
  :custom
  (vertico-cycle t)
  (vertico-mouse-mode t)
  (vertico-multiform-categories
   '((file grid reverse)
     (consult-location buffer)
     (consult-grep buffer)
     (minor-mode reverse)
     (imenu buffer)
     (t unobtrusive)))

  (vertico-multiform-commands
   '((consult-dir reverse)
     (execute-extended-command flat)
     (embark-prefix-help-command reverse)
     (completion-at-point reverse))))
#+end_src

Mini-buffers should be tweaked a little to accommodate our =Vertico= buffers.

#+begin_src emacs-lisp
(use-feature emacs
  :preface
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" "" crm-separator)
                  (car args))
          (cdr args)))
  :hook (minibuffer-setup . cursor-intangible-mode)
  :config
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)
  (setq enable-recursive-minibuffers t
        minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt)))
#+end_src

As of now, I am not planning on having my =Vertico= buffers float. But I might change myself later, hence why I choose to retain the code block below.

#+begin_src emacs-lisp :tangle no
(use-package vertico-posframe
  :requires (vertico)
  :hook (vertico-mode . vertico-posframe-mode)
  :custom
  (vertico-posframe-poshandler #'posframe-poshandler-frame-top-center)
  (vertico-posframe-fallback-mode vertico-buffer-mode))
#+end_src

**** Marginalia: Annotate The Mini-Buffer

#+begin_src emacs-lisp
(use-package marginalia
  :config (marginalia-mode t)
  :custom
  (marginalia-max-relative-age 0)
  (marginalia-align 'right))
#+end_src

**** Terminal Work & Emulation Within Emacs

#+begin_src emacs-lisp
(use-feature tramp
  :defer t
  :config
  (setq remote-file-name-inhibit-cache nil)
  (add-to-list 'tramp-connection-properties
               (list (regexp-quote "/ssh:YOUR_HOSTNAME:")
                     "direct-async-process" t))
  :custom
  (tramp-verbose 0)
  (tramp-chunksize 2000)
  (tramp-use-ssh-controlmaster-options nil))
#+end_src

***** Eshell: Emacs-Lisp Shell

=Eshell= is a bit special, it acts as a seperate shell from your system shell and therefore you won't access your system shell environment by default. And it also comes with unpolished aesthetics IMO, therefore I thought I should clean it up a bit.

#+begin_src emacs-lisp
(use-feature eshell
  :commands (project-eshell)
  :preface
  <<eshell-shorten-directory-path>>
  <<eshell-redesign-prompt>>
  :custom
  (eshell-error-if-no-glob t)
  (eshell-hist-ignoredups t)
  (eshell-save-history-on-exit t)
  (eshell-scroll-to-bottom-on-input 'this)
  (eshell-scroll-to-bottom-on-output nil)
  (eshell-destroy-buffer-when-process-dies t)
  ;; :NOTE| Aesthetics of our semi-cursed prompt?
  (eshell-prompt-function #'irkalla/eshell-prompt)
  (eshell-prompt-regexp "^.*â””â”€âž¤ ðº "))
#+end_src

****** Shorten Directory Path Length

#+NAME: eshell-shorten-directory-path
#+begin_src emacs-lisp :tangle no
(defun shortened-path (path max-len)
  (require 'cl-lib)
  (let* ((components (split-string (abbreviate-file-name path) "/"))
         (len (+ (1- (length components))
                 (cl-reduce '+ components :key 'length)))
         (str ""))
    (while (and (> len max-len) (cdr components))
      (setq str (concat str (if (= 0 (length (car components)))
                                "/" (string (elt (car components) 0) ?/)))
            len (- len (1- (length (car components))))
            components (cdr components)))
    (concat str (cl-reduce (lambda (a b) (concat a "/" b)) components))))
#+end_src

****** A Different Prompt Aesthetic

Because I cannot integrate [[https://github.com/starship/starshipstarship-rs][starship-rs]] with =Eshell=, I am forced to take things into hand.

#+NAME: eshell-redesign-prompt
#+begin_src emacs-lisp :tangle no
  (defun irkalla/eshell-prompt ()
    (concat
     (propertize (concat " ï¼ " (shortened-path (eshell/pwd) 40)) 'face 'font-lock-constant-face)
     (when (package-installed-p 'magit)
       (propertize (if (magit-get-current-branch)
                       (concat "  ï‚› " (magit-get-current-branch)) "" 'face 'font-lock-variable-name-face)))
     (when (package-installed-p 'envrc)
       (propertize (if (string= envrc--status 'none)
                       "" "  ïŠ™ " 'face 'font-lock-string-face)))
     (propertize (concat "  î™ " (format-time-string "%H:%M" (current-time))) 'face 'font-lock-variable-name-face)
     (propertize "\n â””â”€âž¤ ðº " 'face 'font-lock-type-face)))
#+end_src

****** Hydra: Eshell Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ launcher-hydra ()
    ("Terminal"
     (("l" project-eshell "Eshell -> Project")
      ("n" nix-shell      "Eshell -> Nix")))))
#+end_src

***** EAT: Terminal Emulator In Lisp
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(use-package eat
  :ensure (:host codeberg :repo "akib/emacs-eat"
                 :files ("*.el" ("term" "term/*.el") "*.texi"
                         "*.ti" ("terminfo/e" "terminfo/e/*")
                         ("terminfo/65" "terminfo/65/*")
                         ("integration" "integration/*")
                         (:exclude ".dir-locals.el" "*-tests.el")))
  :hook ((eshell-mode . (lambda ()
                          (eat-eshell-mode)
                          (eat-eshell-visual-command-mode))))
  :custom
  (eat-kill-buffer-on-exit t)
  (eat-enable-auto-line-mode t))
#+end_src

****** Hydra: EAT Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ launcher-hydra ()
    ("Terminal"
     (("e" eat         "EAT")
      ("p" eat-project "EAT -> Project")))))
#+end_src

***** VTerm: Fully-Fledged Terminal

#+begin_src emacs-lisp
(use-feature vterm
  :commands (vterm)
  :hook (vterm-mode . evil-emacs-state)
  :bind (:map vterm-mode-map
              ("<S-prior>" . #'scroll-down-command)
              ("<S-next>"  . #'scroll-up-command))
  :custom
  (vterm-timer-delay 0.01)
  (vterm-max-scrollback 10000)
  (vterm-clear-scrollback-when-clearing t))
#+end_src

****** Hydra: VTerm Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ launcher-hydra ()
    ("Terminal"
     (("e" vterm "VTerm")
      ("p" projectile-run-vterm "VTerm -> Project")))))
#+end_src

*** Trivial Changes To Extend Workflow

**** Life Without Reading Sucks

***** PDF Reader

#+begin_src emacs-lisp
(use-feature pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :mode ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
  :hook (pdf-view-mode . pdf-view-midnight-minor-mode)
  :bind (:map pdf-view-mode-map ([tab] . pdf-outline))
  ;; :HACK| Resolves elpaca's failure to detect ~epdfinfo~
  :init (add-to-list 'elpaca-ignored-dependencies 'pdf-tools)
  :config
  ;; :NOTE| Set the PDF free from the unnecessary borders.
  (when (featurep 'evil)
    (add-hook 'pdf-view-mode-hook
              (lambda () (set (make-local-variable 'evil-normal-state-cursor)
                              (list nil)))))

  ;; :NOTE| Load PDF-Tools utilities when installed from Nix || Guix.
  (if IS-REPRO (let ((inhibit-message t))
                 (load-library "pdf-tools-autoloads")))

  ;; :NOTE|Auto center PDF page on zoom-in/out.
  (advice-add 'pdf-view-enlarge :after (lambda (&rest _args) (pdf-view-center-in-window)))
  (advice-add 'pdf-view-shrink :after (lambda (&rest _args) (pdf-view-center-in-window)))
  :custom
  (pdf-view-use-scaling t)
  (pdf-view-use-imagemagick nil)
  (pdf-view-display-size 'fit-width)
  (pdf-view-midnight-colors '("#cdd6f4" . "#1e1e2e")))
#+end_src

Instead of maintaining a bookmark for each PDF file I read, I decided to add a package to help me defer that process.

#+begin_src emacs-lisp
(use-package pdf-view-restore
  :hook (pdf-view-mode . pdf-view-restore-mode)
  :custom (pdf-view-restore-filename (no-littering-expand-var-file-name "pdf-view-restore")))
#+end_src

***** EPUB Reader

#+begin_src emacs-lisp
(use-package nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (with-eval-after-load 'visual-fill-column
    (add-hook 'nov-mode-hook #'visual-fill-column-mode))
  :custom (nov-text-width t))
#+end_src

Being able to render the EPUB files in a cleaner fashion could sometimes be nice.

#+begin_src emacs-lisp
(use-package nov-xwidget
  :ensure (:host github :repo "chenyanming/nov-xwidget")
  :requires (nov)
  :hook (nov-mode . nov-xwidget-inject-all-files)
  :bind (:map nov-mode-map ("o" . #'nov-xwdiget-view)))
#+end_src

***** RSS Reader

#+begin_src emacs-lisp
(use-feature newsticker
  :preface
  (defun irkalla/newsticker-start-newTab ()
    "Launch NewsTicker (TreeView) in a new tab."
    (interactive)
    (let (success)
      (unwind-protect (progn
                        (tab-bar-new-tab)
                        (call-interactively #'newsticker-treeview)
                        (tab-bar-rename-tab "newsticker")
                        (setq success t))
        (unless success (tab-bar-close-tab)))))

  (defun irkalla/newsticker-quit-newTab ()
    "Quit NewsTicker (TreeView) -> stop NewsTicker -> close tab."
    (interactive)
    (newsticker-treeview-quit)
    (newsticker-stop)
    (tab-close))
  :bind (:map newsticker-treeview-mode-map
              ("o" . newsticker-treeview-browse-url)
              ("q" . irkalla/newsticker-quit-newTab))
  :config
  (with-eval-after-load 'visual-fill-column
    (add-hook 'newsticker-treeview-item-mode-hook #'visual-fill-column-mode))
  :custom
  (newsticker-automatically-mark-items-as-old nil)
  (newsticker-automatically-mark-visited-items-as-old t)
  (newsticker-obsolete-item-max-age 259200) ;; 3 days
  (newsticker-retrieval-method 'extern)
  (newsticker-treeview-automatically-mark-displayed-items-as-old nil)

  (newsticker-url-list-defaults nil)
  (newsticker-url-list
   '(("Planet Emacslife"            "https://planet.emacslife.com/atom.xml")
     ("Sacha Chua"                  "https://sachachua.com/blog/feed/")
     ("Mastering Emacs"             "http://www.masteringemacs.org/feed/")
     ;; ---[ Science & Technology ]---
     ("Phys.org: Physics"           "https://phys.org/rss-feed/")
     ("Quanta Magazine"             "https://api.quantamagazine.org/feed/")
     ;; ---[ Mathematics ]---
     ("Arxiv: Mathematics"          "http://arxiv.org/rss/math")
     ("Arxiv: Mathematical Physics" "http://arxiv.org/rss/math-ph")
     ("Terrence Tao (Blog)"         "https://terrytao.wordpress.com/feed/")
     ("Stephen Wolfram (Blog)"      "https://writings.stephenwolfram.com/feed/")
     ;; ---[ Computer Science ]---
     ("Arxiv: Computer Science"     "http://arxiv.org/rss/cs")
     ;; ---[ Physics ]---
     ("Arxiv: Physics"              "http://arxiv.org/rss/physics")))

  (newsticker-wget-name "curl")
  (newsticker-wget-arguments '("--silent" "--location" "--connect-timeout" "8")))
#+end_src

****** Hydra: Newsticker Commands

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ launcher-hydra ()
    ("Application"
     (("n" irkalla/newsticker-start-newTab "Newsticker (RSS)")))))
#+end_src

**** Communication With The Outside World

Syntax highlighting is a nice feature to have in our different chat clients.

#+begin_src emacs-lisp
(use-package htmlize
  :defer t)
#+end_src

***** NotMuch: Tag Based E-Mail Client

#+begin_src emacs-lisp
(use-package notmuch
  :defer t
  :custom (notmuch-search-oldest-first nil)
  :config
  (with-eval-after-load 'visual-fill-column
    (add-hook 'notmuch-show-mode-hook #'visual-fill-column-mode))

  ;; :NOTE| Configure NotMuch to send E-Mails!
  (setq send-mail-function #'sendmail-send-it
        message-send-mail-function 'message-send-mail-with-sendmail
        sendmail-program (executable-find "msmtp")

        message-fill-column fill-column
        mail-specify-envelope-from t
        mail-envelope-from 'header
        message-sendmail-envelope-from 'header

        notmuch-saved-searches '((:name "Unread"
                                  :query "tag:inbox and tag:unread"
                                  :count-query "tag:inbox and tag:unread"
                                  :sort-order newest-first)
                                 (:name "Inbox"
                                  :query "tag:inbox"
                                  :count-query "tag:inbox"
                                  :sort-order newest-first)
                                 (:name "Archive"
                                  :query "tag:archive"
                                  :count-query "tag:archive"
                                  :sort-order newest-first)
                                 (:name "Sent"
                                  :query "tag:sent or tag:replied"
                                  :count-query "tag:sent or tag:replied"
                                  :sort-order newest-first)
                                 (:name "Trash"
                                  :query "tag:deleted"
                                  :count-query "tag:deleted"
                                  :sort-order newest-first))))
#+end_src

Afterwards we proceed with creating a bridge between =Consult= and =NotMuch=.

#+begin_src emacs-lisp
(use-package consult-notmuch
  :requires (consult notmuch)
  :commands (consult-notmuch))

(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ consult-hydra ()
      ("External"
       (("m" consult-notmuch "Query E-Mail")))))
#+end_src

****** Org-MSG: Compose Org Formatted Messages

#+begin_src emacs-lisp
(use-package org-msg
  :after (notmuch)
  :config
  (org-msg-mode)
  (with-eval-after-load 'notmuch
    (org-msg-mode-notmuch)
    (setq mail-user-agent 'notmuch-user-agent))
  :custom
  (org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil title:nil email:nil tex:imagemagick")
  (org-msg-startup "hidestars indent inlineimages")
  (org-msg-greeting-fmt "\nGreetings %s,\n\n")
  (org-msg-greeting-name-limit 3)
  (org-msg-default-alternatives
   '((new           . (utf-8 html))
     (reply-to-text . (utf-8))
     (reply-to-html . (utf-8 html))))
  (org-msg-convert-citation t)
  (org-msg-signature "
Kind Regards,

#+begin_signature
-- *Icy-Thought*
#+end_signature"))
#+end_src

***** Matrix: Secure & Interoperable Communication

#+begin_src emacs-lisp
(use-package ement
  :commands (ement-connect)
  :bind (:map ement-room-mode-map
              ([remap pixel-scroll-interpolate-up]   . ement-room-scroll-down-command)
              ([remap pixel-scroll-interpolate-down] . ement-room-scroll-up-mark-read))
  :config
  (with-eval-after-load 'visual-fill-column
    (add-hook 'ement-room-mode-hook #'visual-fill-column-mode))

  ;; :NOTE| Enable dictionary + emoji suggestions in compose area
  (add-hook 'ement-room-read-string-setup-hook
            (lambda ()
              (when (featurep 'cape)
                (add-hook 'completion-at-point-functions #'cape-dict nil t)
                (add-hook 'completion-at-point-functions #'cape-emoji nil t))))
  :custom
  ;; :NOTE| Notifications ought to be limited to @mentions only!
  (ement-notify-notification-predicates '(ement-notify--event-mentions-session-user-p
                                          ement-notify--event-mentions-room-p))
  (ement-room-images t)
  (ement-room-message-format-spec "%S>%L %B%r%R[%t]")
  (ement-room-send-message-filter #'ement-room-send-org-filter)
  (ement-save-sessions t))
#+end_src

I also want to write a function that could later be used to spawn an Emacs (matrix) frame by XMonad or other window managers.

#+begin_src emacs-lisp
(defun irkalla/connect-to-matrix ()
  "Connect Emacs to the Matrix, unless connection exists."
  (interactive "p")
  (require 'ement)
  (let* ((matrix-username "@gilganix:matrix.org"))
    (cond
     ((map-elt ement-sessions matrix-username) (ement-room-list))
     ((ement--read-sessions)
      (call-interactively #'ement-connect)
      (message "Connecting to known Ement session..."))
     (t (ement-connect
         :user-id matrix-username
         :password (irkalla/read-secret-file "Ement")
         :uri-prefix "http://localhost:8009")))))
#+end_src

***** Telega: Emacs Telegram Client

#+begin_src emacs-lisp
(use-feature telega ;; <-^ fetched from Nixpkgs
  :commands (telega)
  :config
  (with-eval-after-load 'visual-fill-column
    (add-hook 'telega-chat-mode-hook #'visual-fill-column-mode))

  ;; :NOTE| Enable dictionary + emoji suggestions in compose area
  (when (featurep 'cape)
    (add-hook 'telega-chat-mode-hook
              (lambda ()
                (add-hook 'completion-at-point-functions #'cape-dict nil t)
                (add-hook 'completion-at-point-functions #'cape-emoji nil t))))
  :custom
  (telega-directory (no-littering-expand-var-file-name "telega/"))
  (telega-chat-bidi-display-reordering t)
  (telega-notifications-mode t)
  (telega-emoji-use-images nil)) ;; recent libsvg issue..
#+end_src

***** Circle: IRC Client

#+begin_src emacs-lisp
(use-package circe
  :commands (circe circe-set-display-handler)
  :config (enable-circe-color-nicks)
  :custom (circe-reduce-lurker-spam t)
  (circe-network-options
   '(("Libera Chat"
      :tls t
      :nick "Icy-Thought"
      :sasl-username "icy-thought"
      ;; :sasl-password (irkalla/read-secret-file "IRC")
      :channels ("#guix")))))
#+end_src

**** Browsing The Web

***** GNU Emacs Web Browser (EWW)

#+begin_src emacs-lisp
(use-feature eww
  :preface
  (defun auto-readable-wikipedia ()
    "Run `eww-readable' if the current buffer is a Wikipedia article."
    (when (and (eq major-mode 'eww-mode)
               (string-match-p "\\bwikipedia\\.org\\b" (eww-current-url)))
      (eww-readable)))
  :hook (eww-after-render . auto-readable-wikipedia))
#+end_src

***** Shrface: Org Like Rendering For The Web

#+begin_src emacs-lisp
(use-package shrface
  :after (shr)
  :hook ((shrface-mode . variable-pitch-mode)
         (eww-after-render . shrface-mode))
  :custom (shrface-href-versatile t)
  :config
  (shrface-basic)
  (shrface-trial)
  (shrface-default-keybindings)

  ;; :NOTE| allow shrface to control nov.el buffers
  (with-eval-after-load 'nov
    (setq nov-shr-rendering-functions '((img . nov-render-img) (title . nov-render-title))
          nov-shr-rendering-functions (append nov-shr-rendering-functions shr-external-rendering-functions))
    (add-hook 'nov-mode-hook #'shrface-mode))

  (with-eval-after-load 'visual-fill-column
    (add-hook 'shrface-mode-hook #'visual-fill-column-mode))

  (with-eval-after-load 'org-modern
    (setq shrface-bullets-bullet-list (string-glyph-split org-modern-replace-stars))))
#+end_src

I also would like for web-pages to properly render code blocks, and that is by displaying them with the appropriate syntax highlighting.

#+begin_src emacs-lisp
(use-package shr-tag-pre-highlight
  :requires (shrface)
  :hook (eww-after-render . (lambda ()
                              (require 'shr-tag-pre-highlight)
                              (add-to-list 'shr-external-rendering-functions
                                           '(pre . shr-tag-pre-highlight)))))
#+end_src

** Part 4: Editing Environment

*** Alternative Editing Bindings

**** EVIL: VIM Layer For Emacs

#+begin_src emacs-lisp
(use-package evil
  :preface
  (defun irkalla/extended-escape ()
    (interactive)
    (if (evil-ex-hl-active-p 'evil-ex-search)
        (evil-ex-nohighlight)
      (evil-force-normal-state)))
  :bind (:map evil-normal-state-map ("<escape>" . irkalla/extended-escape))
  :init
  (setq evil-want-keybinding nil)
  (evil-mode t)
  :custom
  (evil-search-module 'evil-search)
  (evil-respect-visual-line-mode t)
  (evil-undo-system 'undo-fu)
  (evil-vsplit-window-right t))
#+end_src

***** Evil-Collection: A Collection Of Many Evil Bindings

#+begin_src emacs-lisp
(use-package evil-collection
  :requires (evil)
  :config (evil-collection-init)
  :custom
  (evil-collection-setup-minibuffer t)
  (evil-collection-magit-want-horizontal-movement t)
  (evil-collection-magit-use-y-for-yank t))
#+end_src

***** EVIL-Snipe: 2-Char Word Word Search

#+begin_src emacs-lisp
(use-package evil-snipe
  :requires (evil)
  :hook (((prog-mode text-mode) . evil-snipe-local-mode)
         (evil-snipe-local-mode . evil-snipe-override-local-mode))
  :custom
  (evil-snipe-scope 'visible)
  (evil-snipe-repeat-scope 'whole-visible)
  (evil-snipe-spillover-scope nil)
  :config (push '(?\[ "[[{(]") evil-snipe-aliases))
#+end_src

***** EVIL Surround Word With SYMB

#+begin_src emacs-lisp
(use-package evil-surround
  :requires (evil)
  :config (global-evil-surround-mode))
#+end_src

***** EVIL Action Highlight

#+begin_src emacs-lisp
(use-package evil-goggles
  :requires (evil)
  :config (evil-goggles-mode)
  :custom (evil-goggles-duration 0.1))
#+end_src

***** EVIL (Line/Block) Commenting

#+begin_src emacs-lisp
(use-package evil-nerd-commenter
  :requires (evil)
  :commands (evilnc-comment-or-uncomment-lines
             evilnc-comment-or-uncomment-paragraphs))
#+end_src

****** Hydra: Evil Comment Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ editor-hydra ()
    ("Action"
     ((";" evilnc-comment-or-uncomment-lines      "Comment line"))))

  (pretty-hydra-define+ visual-editor-hydra ()
    ("Action"
     ((";" evilnc-comment-or-uncomment-lines "Comment Line(s)")))))
#+end_src

**** MEOW: Modular Editing
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(use-package meow
  :custom-face
  (meow-beacon-indicator ((t (:inherit telephone-line-evil-emacs))))
  (meow-insert-indicator ((t (:inherit telephone-line-evil-insert))))
  (meow-motion-indicator ((t (:inherit telephone-line-evil-motion))))
  (meow-normal-indicator ((t (:inherit telephone-line-evil-motion))))
  (meow-keypad-indicator ((t (:inherit telephone-line-evil-operator))))
  :custom
  (meow-keypad-self-insert-undefined nil)
  (meow-keypad-ctrl-meta-prefix nil)
  (meow-keypad-literal-prefix ?\s)
  (meow-keypad-meta-prefix ?m)
  (meow-keypad-start-keys '((?c . ?c) (?u . ?u) (?x . ?x)))
  (meow-mode-state-list '((vterm-mode . insert)))

  (meow-expand-hint-remove-delay 1.5)
  (meow-esc-delay 0.001)
  (meow-expand-exclude-mode-list nil)
  :config
  (meow-global-mode t)
  (meow-qwerty-setup)
  (meow-setup-indicator)
  (meow-setup-line-number)

  ;; :NOTE| meow-things related bindings
  (meow-thing-register 'tex-round  '(pair ("\\left(") ("\\right)"))     '(pair ("\\left(") ("\\right)")))
  (meow-thing-register 'tex-square '(pair ("\\left[") ("\\right]"))     '(pair ("\\left[") ("\\right]")))
  (meow-thing-register 'tex-curly  '(pair ("\\left\\{") ("\\right\\}")) '(pair ("\\left\\{") ("\\right\\}")))

  (meow-thing-register 'angle      '(pair ("<") (">")) '(pair ("<") (">")))
  (meow-thing-register 'quote-gqq  '(pair ("â€ž") ("â€œ")) '(pair ("â€ž") ("â€œ")))
  (meow-thing-register 'quote-gq   '(pair ("â€š") ("â€˜")) '(pair ("â€š") ("â€˜")))
  (meow-thing-register 'quote-eqq  '(pair ("â€œ") ("â€")) '(pair ("â€œ") ("â€")))
  (meow-thing-register 'quote-eq   '(pair ("â€˜") ("â€™")) '(pair ("â€˜") ("â€™")))

  ;; Later we inform Meow about our new changes
  (setq meow-char-thing-table
        '((?\( . round)  (?\) . round)
          (?\[ . square) (?\] . square)
          (?\{ . curly)  (?\} . curly)
          (?p  . paragraph) (?l  . line) (?\" . string)
          (?â€ž  . quote-gqq) (?â€š  . quote-gq)
          (?\â€œ . quote-eqq) (?\â€˜ . quote-eq)
          (?s  . symbol)    (?.  . sentence) (?a . angle) (?b . buffer)
          (?r  . tex-round) (?s  . tex-square) (?c . tex-curly))))
#+end_src

***** QWERTY Layout

#+begin_src emacs-lisp
(defun meow-qwerty-setup ()
  "Simple bindings intended to make our Meow workflow more fluid."
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty
        meow-use-cursor-position-hack t
        meow-selection-command-fallback '((meow-change . meow-change-char)
                                          ;; (meow-kill . meow-C-k)
                                          (meow-kill . meow-delete)
                                          ;; (meow-cancel-selection . keyboard-quit)
                                          (meow-cancel-selection . ignore)
                                          (meow-pop-selection . meow-pop-grab)
                                          (meow-beacon-change . meow-beacon-change-char)))

  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   '("/" . consult-line)
   '("<escape>" . keyboard-quit))

  (meow-leader-define-key
   ;; SPC j/k will run the original command in MOTION state.
   '("j" . "H-j")
   '("k" . "H-k")
   '("/" . "H-/")

   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))

  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)

   '("~" . upcase-char)
   '("-" . negative-argument)
   '("=" . indent-region)
   '(":" . recenter-top-bottom)
   '(";" . meow-reverse)
   '("." . repeat)
   '("<" . meow-inner-of-thing)
   '(">" . meow-bounds-of-thing)
   '("(" . backward-sexp)
   '(")" . forward-sexp)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '("/" . consult-line)
   '("?" . comment-dwim)
   '("<next>" . consult-buffer)
   '("<escape>" . meow-cancel-selection)

   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-join)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . execute-extended-command)
   '("n" . meow-search)
   '("v" . meow-block)
   '("V" . meow-to-block)
   '("o" . meow-open-below)
   '("O" . meow-open-above)
   '("p" . meow-yank)
   '("P" . meow-yank-pop)
   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-grab)
   '("t" . meow-till)
   '("u" . undo)
   '("U" . undo-redo)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)))
#+end_src

*** The Basic Requirements Of An Editor

#+begin_src emacs-lisp
(use-feature emacs
  :init (with-eval-after-load 'projectile
          (projectile-mode t))
  :custom
  (confirm-nonexistent-file-or-buffer nil)
  (backward-delete-char-untabify-method 'hungry)
  (electric-indent-inhibit t)
  (indent-tabs-mode nil)
  (standard-indent 4)
  (tab-width 4)
  (fill-column 120)
  (truncate-lines t)
  (truncate-string-ellipsis "â†´")
  (find-file-suppress-same-file-warnings t)
  (remote-file-name-inhibit-locks t)
  (x-stretch-cursor t)
  (text-mode-ispell-word-completion nil))
#+end_src

**** Update Files When Changed

#+begin_src emacs-lisp
(use-feature autorevert
  :hook ((prog-mode text-mode) . auto-revert-mode)
  :custom
  (auto-revert-interval 1)
  (auto-revert-notify t)
  (auto-revert-verbose t))
#+end_src

**** Uniform Editing Environment

Since I work with other developers I need to add one package that could help reduce the burden of formatter wars and whatnot, =editorconfig= that is.

#+begin_src emacs-lisp
(use-package editorconfig
  :hook (prog-mode . editorconfig-mode))
#+end_src

Also, not all system environments will contain the necessary packages required to work with certain projects. Therefore packages like =direnv= was created, to automatically install/load the environment of a specific project.

#+begin_src emacs-lisp
(use-package direnv
  :config
  (direnv-mode t)
  (add-to-list 'warning-suppress-types '(direnv))
  :custom (direnv-always-show-summary nil))
#+end_src

**** Enhancing The Aesthetics A Little

***** Number Line

#+begin_src emacs-lisp
(use-feature display-line-numbers
  :hook ((prog-mode text-mode conf-mode) . display-line-numbers-mode)
  :custom (display-line-numbers-type 'relative))
#+end_src

***** Matching Parentheses

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

***** Colorful Indentation Levels

#+begin_src emacs-lisp
(use-package indent-bars
  :ensure (:host github :repo "jdtsmith/indent-bars")
  :hook (prog-mode . indent-bars-mode)
  :custom
  (indent-bars-zigzag nil)
  (indent-bars-treesit-support t)
  (indent-bars-treesit-ignore-blank-lines-types '("module")))
#+end_src

***** Painting Hex/RGB Colors

#+begin_src emacs-lisp
(use-package rainbow-mode
  :hook (prog-mode . rainbow-mode))
#+end_src

***** Highlight Current Line

#+begin_src emacs-lisp
(use-feature hl-line
  :hook ((prog-mode text-mode) . hl-line-mode))
#+end_src

***** Window Frames

#+begin_src emacs-lisp
(use-feature frame
  :hook ((prog-mode text-mode) . window-divider-mode)
  :custom
  (window-divider-default-places t)
  (window-divider-default-right-width 2)
  (window-divider-default-bottom-width 2))
#+end_src

***** Noticeable Whitespaces

#+begin_src emacs-lisp
(use-feature whitespace
  :commands (whitespace-mode)
  :hook (before-save . whitespace-cleanup)
  :custom
  (whitespace-style '(face indentation trailing newline empty))
  (whitespace-display-mappings
   '(;; space (Â·) else (.)
     (space-mark 32 [183] [46])
     ;; new line (Â¬) else ($)
     (newline-mark ?\n [172 ?\n] [36 ?\n])
     ;; carriage return (Â¶) else (#)
     (newline-mark ?\r [182] [35])
     ;; tabs (Â») else (>)
     (tab-mark ?\t [187 ?\t] [62 ?\t]))))
#+end_src

****** Hydra: Whitespace Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ window-hydra ()
    ("Main"
     (("w" whitespace-mode "Whitespace Mode" :toggle t)))))
#+end_src

***** Ligatures: Cleaner Display Of SYMB

#+begin_src emacs-lisp
(use-package ligature
  :config
  (global-ligature-mode t)
  (ligature-set-ligatures 't '("www"))
  (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
  (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://")))
#+end_src

***** Visual Fill Column:

#+begin_src emacs-lisp
(use-package visual-fill-column
  :commands (visual-fill-column-mode)
  :hook ((visual-fill-column-mode . visual-line-mode)
         (text-mode . visual-fill-column-mode))
  :custom (visual-fill-column-center-text t))
#+end_src

**** Elec-Pair: Insert Matching SYMB

#+begin_src emacs-lisp
(use-feature elec-pair
  :hook ((prog-mode text-mode) . (lambda ()
                                   (unless (derived-mode-p 'emacs-lisp-mode 'lisp-mode)
                                     (electric-pair-local-mode))))
  :custom (electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit))
#+end_src

**** Jinx: Elegant Spell Checker

#+begin_src emacs-lisp
(use-feature jinx ;; <-^ fetched from Nixpkgs
  :commands (jinx-correct)
  :hook (text-mode . jinx-mode)
  :bind ([remap ispell-word] . jinx-correct))
#+end_src

**** Separate Emacs Clipboard From System

***** Copying To System Clipboard

#+begin_src emacs-lisp
(defun irkalla/copy-to-sysclip ()
  "Copy contents to the system clipboard."
  (interactive)
  (setq select-enable-clipboard t)
  (if (featurep 'evil)
      (call-interactively #'evil-yank)
    (kill-ring-save (region-beginning) (region-end)))
  (setq select-enable-clipboard nil))
#+end_src

***** Pasting From System Clipboard

#+begin_src emacs-lisp
(defun irkalla/paste-from-sysclip ()
  "Paste contents to the system clipboard."
  (interactive)
  (setq select-enable-clipboard t)
  (if (featurep 'evil)
      (call-interactively #'evil-paste-after)
    (yank))
  (setq select-enable-clipboard nil))
#+end_src

***** Hydra: Clipboard Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ editor-hydra ()
    ("Action"
     (("y" irkalla/copy-to-sysclip "Yank -> Sys-Clip")
      ("p" irkalla/paste-from-sysclip "Paste <- Sys-Clip"))))

  (pretty-hydra-define+ visual-editor-hydra ()
    ("Action"
     (("y" irkalla/copy-to-sysclip "Yank -> Sys-Clip")))))
#+end_src

*** Expanding On The Basic Requirements

**** Maintaining A Clean History

#+begin_src emacs-lisp
(use-feature emacs
  :custom
  (auto-save-interval 200)
  (auto-save-timeout 30)
  (backup-by-copying t)
  (delete-by-moving-to-trash t)
  (delete-old-versions t)
  (history-delete-duplicates t)
  (history-length 1000)
  (kept-new-versions 7)
  (kept-old-versions 3)
  (make-backup-files t))
#+end_src

***** Archive File History

#+begin_src emacs-lisp
(use-feature savehist
  :defer 1
  :config (savehist-mode t)
  :custom
  (savehist-autosave-interval 60)
  (savehist-file (no-littering-expand-var-file-name "savehist"))
  (savehist-additional-variables '(command-history evil-jumps-history))
  (savehist-ignored-variables '(ement-room-message-history)))
#+end_src

***** Memorize File Paths

#+begin_src emacs-lisp
(use-feature saveplace
  :hook ((prog-mode text-mode) . save-place-mode)
  :custom
  (save-place-file (no-littering-expand-var-file-name "saveplace"))
  (save-place-forget-unreadable-files t))
#+end_src

***** Undo-Fu: Wrapper For Built-in Undo System

#+begin_src emacs-lisp
(use-package undo-fu
  :if (>= emacs-major-version 29)
  :config
  (setq undo-no-redo      t
        undo-limit        (* 128 1024 1024)
        undo-outer-limit  (* 128 1024 1024)
        undo-strong-limit (* 256 1024 1024)))
#+end_src

Also, =Undo-Fu= activity ought to be tracked and saved for future sessions.

#+begin_src emacs-lisp
(use-package undo-fu-session
  :requires (undo-fu)
  :hook ((prog-mode text-mode) . global-undo-fu-session-mode)
  :custom
  (undo-fu-session-directory (no-littering-expand-var-file-name "undo-fu-session/"))
  (undo-fu-session-compression (if (executable-find "zstd") 'zst 'gz))
  (undo-fu-session-incompatible-files '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'")))
#+end_src

***** Vundo: Visualize Undo History

#+begin_src emacs-lisp
(use-package vundo
  :commands (vundo)
  :bind (("C-c u" . vundo))
  :custom
  (vundo-compact-display t)
  (vundo-glyph-alist vundo-unicode-symbols))
#+end_src

**** Ediff: Display File Difference(s)

#+begin_src emacs-lisp
(use-feature ediff
  :hook((ediff-prepare-buffer . outline-show-all)
        (ediff-quit . winner-undo))
  :custom
  (ediff-window-setup-function 'ediff-setup-windows-plain)
  (ediff-split-window-function 'split-window-horizontally)
  (ediff-merge-split-window-function 'split-window-horizontally))
#+end_src

**** Regional Specific Manipulations

***** Align Highlighted Region

#+begin_src emacs-lisp
(use-package ialign
  :commands (ialign))
#+end_src

****** Hydra: Alignment Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ visual-editor-hydra ()
    ("Action"
     (("a" ialign "Align -> REGEXP")))))
#+end_src

***** Expand Region Selection

#+begin_src emacs-lisp
(use-package expand-region
  :commands (er/expand-region er/contract-region))
#+end_src

****** Hydra: Regional Expansion Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ visual-editor-hydra ()
    ("Navigation"
     ((")" er/expand-region   "Increase -> semantic units")
      ("(" er/contract-region "Contract -> PREV size")))))
#+end_src

***** Highlight Matching Parentheses

#+begin_src emacs-lisp
(use-feature paren
  :hook (prog-mode . show-paren-mode)
  :custom
  (show-paren-style 'parenthesis)
  (show-paren-when-point-in-periphery nil)
  (show-paren-when-point-inside-paren nil))
#+end_src

***** Sub-Word Navigation

#+begin_src emacs-lisp
(use-feature subword
  :hook ((prog-mode text-mode) . subword-mode))
#+end_src

**** Magit: Git Porcelain Inside Emacs

#+begin_src emacs-lisp
(use-package magit
  :if (executable-find "git")
  :commands (magit)
  :init
  (with-eval-after-load 'elpaca
    (setq elpaca-ignored-dependencies ;; :NOTE| Too many Transient complaints to ignore...
          (delq 'transient elpaca-ignored-dependencies)))
  :custom
  (magit-refs-show-commit-count 'all)
  (magit-save-repository-buffers 'dontask)
  (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
#+end_src

***** File-Icons: Buffer Specific Icons

#+begin_src emacs-lisp
(use-package magit-file-icons
  :requires (magit)
  :hook (magit-status-mode . magit-file-icons-mode)
  :custom
  (magit-file-icons-enable-diff-file-section-icons t)
  (magit-file-icons-enable-untracked-icons t)
  (magit-file-icons-enable-diffstat-icons t))
#+end_src

***** Hydra: Magit Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define vc-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Editor: Version Control ï½£â”€â”€" 'mdicon "nf-md-git")
            :color teal :quit-key "q")
    ("Magit"
     (("g" magit                     "Open Magit")
      ("s" magit-stage-buffer-file   "Stage file")
      ("u" magit-unstage-buffer-file "Unstage file")
      ("b" magit-branch-checkout     "Checkout Branch"))))

  (pretty-hydra-define+ editor-hydra ()
    ("Control"
     (("g" vc-hydra/body "Version Control")))))
#+end_src

***** Highlight Repository TODO's

#+begin_src emacs-lisp
(use-package hl-todo
  :ensure (hl-todo :version (lambda (_) "3.6.0"))) ;; elpaca

(use-package magit-todos
  :requires (magit)
  :hook (magit-mode . magit-todos-mode)
  :custom
  (magit-todos-recursive t)
  (magit-todos-depth 10)
  (magit-todos-exclude-globs '(".git/" "*.html"))
  (magit-todos-nice (if (executable-find "nice") t nil))
  (magit-todos-scanner #'magit-todos--scan-with-rg))
#+end_src

***** Git Blame Buffer Line(s)

#+begin_src emacs-lisp
(use-package blamer
  :if (executable-find "git")
  :commands (blamer-show-posframe-commit-info)
  :custom-face
  (blamer-face ((t (:background nil :height 125 :italic t))))
  :custom
  (blamer-idle-time 0.5)
  (blamer-min-offset 70)
  (blamer-view 'overlay-right)
  (blamer-type 'visual)
  (blamer-max-commit-message-length 70)
  (blamer-force-truncate-long-line nil)
  (blamer-author-formatter " âœŽ %s ")
  (blamer-commit-formatter "â— \'%s\' â— "))
#+end_src

****** Hydra: Git Blamer Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ vc-hydra ()
    ("Blamer"
     (("i" blamer-show-posframe-commit-info "Commit Info")))))
#+end_src

***** Highlight Git Buffer Changes

#+begin_src emacs-lisp
(use-package git-gutter
  :if (executable-find "git")
  :hook (prog-mode . git-gutter-mode)
  :custom
  (git-gutter:modified-sign "â”ƒ")
  (git-gutter:added-sign "â”ƒ")
  (git-gutter:deleted-sign "â”ƒ")
  (git-gutter:unchanged-sign "")
  (git-gutter:update-interval 0.05))
#+end_src

****** Hydra: Git Gutter Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ vc-hydra ()
    ("Git-Gutter"
     (("m" git-gutter:mark-hunk             "Mark hunk")
      ("k" git-gutter:previous-hunk         "Previous hunk")
      ("j" git-gutter:next-hunk             "Next hunk")
      ("u" git-gutter:revert-hunk           "Revert hunk")))))
#+end_src

**** Activities: Bookmarking Workspaces

#+begin_src emacs-lisp
(use-package activities
  :defer 1
  :config (activities-mode t)
  :custom (activities-name-prefix "Emacs-NSP| ")) ;; XMonad Scratchpad
#+end_src

***** Hydra: Activities Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define activities-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Utilities: Activities ï½£â”€â”€" 'mdicon "nf-md-file_tree")
            :color teal :quit-key "q")
    ("Workflow"
     (("l"     activities-list     "List")
      ("RET"   activities-switch   "Switch")
      ("e"     activities-rename   "Rename")
      ("w"     activities-save-all "Save All"))
     "Task Operation"
     (("n"     activities-new      "Create")
      ("k"     activities-kill     "Kill")
      ("u"     activities-revert   "Revert"))
     "Pause/Resume"
     (("s"     activities-suspend  "Suspend")
      ("r"     activities-resume   "Resume")
      ("d"     activities-discard  "Discard"))))

  (pretty-hydra-define+ editor-hydra ()
    ("Control"
     (("a" activities-hydra/body "Activities")))))
#+end_src

** Part 5: Completion & Debugging

#+begin_src emacs-lisp
(use-feature emacs
  :custom
  (compilation-always-kill t)
  (compilation-ask-about-save nil)
  (compilation-scroll-output t)
  (compilation-scroll-output t)

  (read-buffer-completion-ignore-case t)
  (read-file-name-completion-ignore-case t)
  (read-extended-command-predicate #'command-completion-default-include-p))
#+end_src

*** Orderless: Completion Candidate Matching

#+begin_src emacs-lisp
(use-package orderless
  :custom
  (completion-category-defaults nil)
  (completion-styles '(orderless basic partial-completion))
  (completion-category-overrides '((file  (styles . (orderless flex)))))
  (completions-detailed t)
  (completion-ignore-case t))
#+end_src

*** Breadcrumb: Location Indicator For Larger Projects

#+begin_src emacs-lisp
(use-package breadcrumb
  :hook (prog-mode . breadcrumb-local-mode)
  :config (fset 'breadcrumb--project-crumbs-1 #'ignore)
  :custom (breadcrumb-project-max-length -1))
#+end_src

*** Apheleia: Code Formatter

#+begin_src emacs-lisp
(use-package apheleia
  :defer t
  :commands (apheleia-format-buffer))
#+end_src

**** Hydra: Apheleia Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ editor-hydra ()
    ("Programming"
     (("!" apheleia-mode "Fmt On Save" :toggle t))
     "Action"
     (("=" apheleia-format-buffer "Buf. Format")))))
#+end_src

*** Corfu: Elegant Completion UI

#+begin_src emacs-lisp
(use-package corfu
  :ensure (:files (:defaults "extensions/*.el"))
  :bind (:map corfu-map
              ("TAB" . corfu-next)
              ([tab] . corfu-next)
              ("S-TAB" . corfu-previous)
              ([backtab] . corfu-previous))
  :init (global-corfu-mode)
  :custom
  (corfu-auto t)
  (corfu-auto-prefix 1)
  (corfu-auto-delay 0.05))
#+end_src

**** Popup $SYMB Information

#+begin_src emacs-lisp
(use-feature corfu-popupinfo
  :requires (corfu)
  :hook (corfu-mode . corfu-popupinfo-mode)
  :custom (corfu-popupinfo-delay '(0.5 . 0.2)))
#+end_src

**** Icons For Completion Menu Item(s)

#+begin_src emacs-lisp
(use-package kind-icon
  :requires (corfu)
  :config (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)
  :custom (kind-icon-default-face 'corfu-default))
#+end_src

*** Cape: Controlling Suggestion Output

#+begin_src emacs-lisp
(use-package cape
  :custom (cape-dict-file (getenv "WORDLIST"))
  :config
  (add-hook 'prog-mode-hook
            (lambda ()
              (add-hook 'completion-at-point-functions #'cape-file nil t)
              (add-hook 'completion-at-point-functions #'cape-keyword nil t)))
  (add-hook 'emacs-lisp-mode-hook
            (lambda () (add-hook 'completion-at-point-functions #'cape-elisp-symbol nil t)))
  (add-hook 'LaTeX-mode-hook
            (lambda () (add-hook 'completion-at-point-functions #'cape-tex nil t)))
  (add-hook 'text-mode-hook
            (lambda ()
              (add-hook 'completion-at-point-functions #'cape-elisp-block nil t)
              (add-hook 'completion-at-point-functions #'cape-dict nil t)
              (add-hook 'completion-at-point-functions #'cape-emoji nil t))))
#+end_src

*** Tempel: Snippet Completion

#+begin_src emacs-lisp
(use-package tempel
  :preface
  (defun setup-capf-tempel ()
    "Temple + Corfu -> display possible snippet completions."
    (add-to-list 'completion-at-point-functions #'tempel-complete))
  :hook ((conf-mode prog-mode text-mode) . setup-capf-tempel)
  :custom
  (tempel-trigger-prefix ",")
  (tempel-path (concat irkalla/main-residence "/snippets/*.eld")))
#+end_src

Instead of defining all of our snippets manually, we could use the help of an external package to help us add the basics and then expand on those bindings with our defined bindings.

#+begin_src emacs-lisp
(use-package tempel-collection
  :requires (tempel))
#+end_src

*** Eldoc: Documentation Of SYMB

#+begin_src emacs-lisp
(use-feature eldoc
  :custom
  (eldoc-idle-delay 1.0)
  (eldoc-echo-area-display-truncation-message nil)
  (eldoc-echo-area-use-multiline-p nil)
  (eldoc-echo-area-prefer-doc-buffer t)
  (eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly))
#+end_src

Documentation of ~$SYMB~ should be displayed in an isolated box, where viewing becomes pleasant.

#+begin_src emacs-lisp
(use-package eldoc-box
  :commands (eldoc-box-help-at-point)
  :hook (eglot-managed-mode . eldoc-box-hover-at-point-mode))
#+end_src

*** Tree-Sitter: Parser Generator Tool

#+begin_src emacs-lisp
(use-package treesit-auto
  :custom (treesit-auto-install nil)
  :config
  (advice-add 'org-src-get-lang-mode
              :filter-return (lambda (mode)
                               (pcase (assoc mode major-mode-remap-alist)
                                 (`(,mode . ,ts-mode) ts-mode) (_ mode))))
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))
#+end_src

**** Tree-Sitter Folding Of Code-Blocks

#+begin_src emacs-lisp
(use-package treesit-fold
  :ensure (:host github :repo "emacs-tree-sitter/treesit-fold")
  :hook (prog-mode . (lambda ()
                       (when (and (treesit-available-p)
                                  (treesit-parser-list))
                         (treesit-fold-mode t)))))
#+end_src

**** Combobulate: Structured Editing & Navigation

#+begin_src emacs-lisp
(use-package combobulate
  :ensure (:host github :repo "mickeynp/combobulate")
  :commands (combobulate)
  :hook (tree-sitter-after-on . combobulate-mode))
#+end_src

***** Hydra: Combobulate Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ editor-hydra ()
    ("Control"
     (("c" combobulate "Combobulate")))))
#+end_src

*** Flymake: Built-in Buffer Diagnostics

#+begin_src emacs-lisp
(use-feature flymake
  :commands (flymake-mode)
  :custom
  (flymake-indicator-type 'margins)
  (flymake-margin-indicator-position 'right-margin)
  (flymake-autoresize-margins t)
  (flymake-margin-indicators-string
   '((error   "îª‡ " compilation-error)
     (warning "î©¬ " compilation-warning)
     (note    "î©´ " compilation-info))))
#+end_src

*** Dape: Debug Adapter Protocol

#+begin_src emacs-lisp
(use-package dape
  :commands (dape)
  :custom
  (dape-key-prefix "\C-x\C-a")
  (dape-buffer-window-arrangement 'right)
  (dape-cwd-fn 'projectile-project-root))
#+end_src

**** Hydra: Dape Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define dape-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Coding: Debugger ï½£â”€â”€" 'codicon "nf-cod-debug")
            :color teal :quit-key "q")
    ("Main"
     (("d" dape "Dape")
      ("k" dape-kill "Kill")
      ("D" dape-disconnect-quit "Disconnect")
      ("Q" dape-quit "Quit" :exit t))
     "Stepping"
     (("n" dape-next "Next")
      ("s" dape-step-in "Step In")
      ("o" dape-step-out "Step Out")
      ("c" dape-continue "Continue")
      ("p" dape-pause "Pause")
      ("r" dape-restart "Restart"))
     "Breakpoint"
     (("b" dape-breakpoint-toggle "Toggle" :toggle t)
      ("l" dape-breakpoint-log "Log")
      ("e" dape-breakpoint-expression "Expression")
      ("B" dape-breakpoint-remove-all "Clear"))
     "Informative"
     (("m" dape-read-memory "Read Memory")
      ("w" dape-watch-dwim "Watch DWIM")
      ("t" dape-select-thread "Select Thread")
      ("S" dape-select-stack "Select Stack")
      ("i" dape-info "Info")
      ("R" dape-repl "REPL"))))

  (pretty-hydra-define+ editor-hydra ()
    ("Control"
     (("d" dape-hydra/body "Dape")))))
#+end_src

*** Leetcode: Dashboard For Code Challenges

#+begin_src emacs-lisp
(use-package leetcode
  :commands (leetcode)
  :custom
  (leetcode-save-solutions t)
  (leetcode-prefer-language "python3")
  (leetcode-directory (no-littering-expand-var-file-name "leetcode/")))
#+end_src

*** ChatGPT: Code Prediction At The Cost Of Freedom
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(use-package chatgpt-shell
  :commands (chatgpt-shell dall-e-shell)
  :custom (chatgpt-shell-openai-key (lambda () (irkalla/read-secret-file "ClosedAI"))))
#+end_src

**** Hydra: ChatGPT Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ editor-hydra ()
    ("ChatGPT"
     (("c" chatgpt-shell "Shell")
      ("d" dall-e-shell  "Dall-E")))))
#+end_src

** Part 6: Language Server Protocols

#+begin_src emacs-lisp
(use-feature eglot
  :demand t
  :pretty-hydra
  ((:title (pretty-hydra-title "â”€â”€ï½¢ Coding: Eglot ï½£â”€â”€" 'faicon "nf-fa-code")
           :color teal :quit-key "q")
   ("Actions"
    (("a" eglot-code-actions    "Perform code-actions")
     ("r" eglot-rename          "Rename $SYMB"))
    "Look-up"
    (("?" xref-find-references  "Find -> references")
     ("f" xref-find-definitions "Find -> definition")
     ("/" xref-find-apropos     "Find $SYMB <- pattern"))))
  :config
  (fset #'jsonrpc--log-event #'ignore) ;; noticeable perf. diff!
  (setf (plist-get eglot-events-buffer-config :size) 0) ;; noticeable perf. diff!
  (with-eval-after-load 'nerd-icons (setq eglot-menu-string "ï„¡ "))
  :custom
  (eglot-autoshutdown t)
  (eglot-extend-to-xref t)
  (eglot-confirm-server-initiated-edits nil)
  (eglot-ignored-server-capabilities '(:documentHighlightProvider)))

(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ editor-hydra ()
    ("Control"
     (("l" (if (eglot-managed-p)
               (eglot-hydra/body)
             (message "You are not in an Eglot buffer.")) "Eglot (LSP)")))))
#+end_src

There is another things that we could utilize to increase the responsiveness of our LSP completions, and that is to add [[https://github.com/jdtsmith/eglot-booster][eglot-booster]] to the stack!

#+begin_src emacs-lisp
(use-package eglot-booster
  :ensure (:host github :repo "jdtsmith/eglot-booster")
  :after (eglot)
  :if (executable-find "emacs-lsp-booster")
  :config (eglot-booster-mode))
#+end_src

*** Emacs Lisp: The Mother-Tounge Of Emacs

**** Maintain Harmony Within The Growing Parentheses

#+begin_src emacs-lisp
(use-package parinfer-rust-mode
  :hook (emacs-lisp-mode . parinfer-rust-mode)
  :custom
  (parinfer-rust-auto-download t)
  (parinfer-rust-library-directory (no-littering-expand-var-file-name "parinfer-rust/")))
#+end_src

**** Hydra: Emacs-Lisp Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define emacs-lisp-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Langspec: Emacs Lisp ï½£â”€â”€" 'sucicon "nf-custom-emacs")
            :color teal :quit-key "q")
    ("Actions"
     (("a" apropos "Show $SYMB == pattern"))))

  (pretty-hydra-define+ editor-hydra ()
    ("Programming"
     (("x" emacs-lisp-hydra/body "Emacs Lisp")))))
#+end_src

*** Guile: Yet Another Lisp Variant
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(use-package geiser-guile
  :defer t
  :mode ("\\.scm\\'" . geiser-mode))
#+end_src

*** Org-Mode: The Superior Documentation Format

#+begin_src emacs-lisp
(use-feature org
  :preface
  (defun irkalla/org-electric-dollar ()
    "Inserts \\( \\) when $, and replaces it with \\[ \\] when $$."
    (interactive)
    (if (and (looking-at "\\\\)")
             (looking-back "\\\\("))
        (progn (delete-char 2)
               (delete-char -2)
               (insert "\\[\\]"))
      (insert "\\(\\)")
      (backward-char 2)))
  :hook (org-mode . org-display-inline-images)
  :config
  (setq org-directory "~/Workspace/memorandum/org-mode")

  (with-eval-after-load 'evil
    (evil-define-key 'insert org-mode-map (kbd "$") #'irkalla/org-electric-dollar))

  ;; :NOTE| Move our LaTeX previews to cache dir
  (let ((latex-dir (no-littering-expand-var-file-name "latex-preview/")))
    (unless (file-directory-p latex-dir)
      (mkdir latex-dir t))
    (setq org-preview-latex-image-directory latex-dir))

  ;; :NOTE| Change the aesthetics of our LaTeX previews
  (setq org-latex-preview-options
        (progn (plist-put org-format-latex-options :background "Transparent")
               (plist-put org-format-latex-options :scale 2.5)
               (plist-put org-format-latex-options :zoom 1.15)))
  :custom
  (org-agenda-files '("~/Workspace/memorandum/org-mode/agenda/init.org"))
  (org-catch-invisible-edits 'show-and-error)
  (org-cycle-include-plain-lists 'integrate)
  (org-cycle-separator-lines 2)
  (org-edit-src-auto-save-idle-delay 5)
  (org-ellipsis "â€¦")
  (org-export-coding-system 'utf-8)
  (org-export-preserve-breaks t)
  (org-fontify-quote-and-verse-blocks t)
  (org-hide-emphasis-markers t)
  (org-highlight-latex-and-related '(native))
  (org-insert-heading-respect-content t)
  (org-latex-tables-centered t)
  (org-special-ctrl-a/e t)
  (org-startup-indented t)
  (org-startup-with-inline-images t)
  (org-support-shift-select t)
  (org-tags-column 0)

  ;; Code blocks
  (org-confirm-babel-evaluate nil)
  (org-edit-src-content-indentation 0)
  (org-src-fontify-natively t)
  (org-src-preserve-indentation t)
  (org-src-tab-acts-natively nil))
#+end_src

**** Hydra: Org-Mode Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define org-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Langspec: Org-Mode ï½£â”€â”€" 'sucicon "nf-custom-orgmode")
            :color teal :quit-key "q")
    ("Buffer"
     (("c" org-capture         "Capture")
      ("e" org-export-dispatch "Export")
      ("t" org-babel-tangle    "Tangle"))))

  (pretty-hydra-define+ editor-hydra ()
    ("Markup"
     (("o" (if (eq major-mode 'org-mode)
               (org-hydra/body)
             (message "You are not in an Org buffer.")) "Org-Mode")))))
#+end_src

**** Org Babel: Code Execution Within Emacs

#+begin_src emacs-lisp
(use-feature ob
  :after (org)
  :hook (org-babel-after-execute . org-display-inline-images)
  :custom
  (org-babel-default-header-args
   '((:async   . "yes")
     (:cache   . "no")
     (:eval    . "never-export")
     (:exports . "both")
     (:hlines  . "no")
     (:noweb   . "yes")
     (:results . "output replace")
     (:session . "none")
     (:tangle .  "no")))
  (org-export-use-babel nil)
  (org-confirm-babel-evaluate nil)
  :config
  <<org-babel-language-on-demand>>
  <<org-babel-execute-action>>
  <<org-babel-tangle-config-on-save>>

  (with-eval-after-load 'evil
    (evil-define-key 'normal org-mode-map (kbd "<return>") #'irkalla/org-execute-action))
  (advice-add 'org-babel-execute-src-block :around #'demand-babel-languages))
#+end_src

***** Org-Babel Language On Demand

Source: https://emacs.stackexchange.com/a/20618

#+NAME: org-babel-language-on-demand
#+begin_src emacs-lisp :tangle no
(defun demand-babel-languages (orig-fun &rest args)
  "Load language if needed before executing a source block."
  (let ((language (org-element-property :language (org-element-at-point))))
    (unless (cdr (assoc (intern language) org-babel-load-languages))
      (add-to-list 'org-babel-load-languages (cons (intern language) t))
      (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
    (apply orig-fun args)))
#+end_src

***** Context Based Babel Action Execution

#+NAME: org-babel-execute-action
#+begin_src emacs-lisp :tangle no
(defun irkalla/org-execute-action ()
  ;; In a source block, call `org-babel-execute-src-block'.
  (interactive)
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      (`src-block
       ;; In a source block, call `org-babel-execute-src-block'.
       (org-babel-eval-wipe-error-buffer)
       (org-babel-execute-src-block current-prefix-arg))
      (`babel-call
       ;; In a `:+CALL:' block, call `org-babel-execute-maybe'.
       (call-interactively #'org-babel-execute-maybe))
      (`table-row
       ;; In a table or table-cell, call `org-table-next-row'.
       (call-interactively #'org-table-next-row))
      ((or `link `timestamp)
       ;; On a link or a timestamp, call `org-open-at-point'.
       (call-interactively #'org-open-at-point))
      (_
       ;; Fallback to evil standard command
       (call-interactively #'forward-line)))))
#+end_src

***** Org-Babel Tangle Configuration On Save

#+NAME: org-babel-tangle-config-on-save
#+begin_src emacs-lisp :tangle no
(defun irkalla/tangle-config-file ()
  "Tangle Irkalla Emacs configuration file on save."
  (when (and (eq major-mode 'org-mode)
             (string= (buffer-file-name)
                      (expand-file-name "config.org" irkalla/main-residence)))
    (org-babel-tangle)))

(add-hook 'after-save-hook 'irkalla/tangle-config-file)
#+end_src

**** TOC: Auto-Generate Table Of Contents

#+begin_src emacs-lisp
(use-package toc-org
  :after (org)
  :hook (org-mode . toc-org-mode)
  :custom (toc-org-max-depth 3))
#+end_src

**** Fragtog: LaTeX Rendering On Hover

#+begin_src emacs-lisp
(use-package org-fragtog
  :after (org)
  :hook (org-mode . org-fragtog-mode))
#+end_src

**** Super-Agenda: Supercharge Your Agendas

#+begin_src emacs-lisp
(use-package org-super-agenda
  :requires (org-agenda)
  :hook (org-agenda-mode .  org-super-agenda-mode)
  :custom
  (org-super-agenda-groups
   '((:name "Today" :time-grid t :todo "TODAY")
     (:name "Important" :tag "bills" :priority "A")
     (:todo "WAITING" :order 8)
     (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING") :order 9)
     (:priority<= "B" :order 1))))
#+end_src

**** Modernize Org-Mode Buffers

#+begin_src emacs-lisp
(use-package org-modern
  :after (org)
  :hook ((org-mode . org-modern-mode)
         (org-agenda-finalize . org-modern-agenda))
  :custom-face (org-modern-symbol ((t (:family "DejaVu Sans"))))
  :custom
  ;; :NOTE| Settings replaced by svg-tag-mode
  (org-modern-tag nil)
  (org-modern-todo nil)
  (org-modern-block-name nil))
#+end_src

**** Searching Org-Mode Files

#+begin_src emacs-lisp
(use-package org-ql
  :after (org)
  :commands (org-ql-search))
#+end_src

***** Hydra: Org-QL Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ org-hydra ()
    ("Project"
     (("/" org-ql-search "Search TAG Org Files")))))
#+end_src

**** Schedule For Your Daily Life

#+begin_src emacs-lisp
(use-package org-timeblock
  :after (org)
  :commands (org-timeblock))
#+end_src

**** Org-Roam: Zettlekasten System For Org-Mode

#+begin_src emacs-lisp
(use-package org-roam
  :after (org)
  :commands (org-roam-graph)
  :custom
  (org-roam-directory (file-truename "~/Workspace/memorandum/org-mode/org-roam"))
  (org-roam-completion-everywhere t)
  (org-roam-capture-templates
   `(("d" "default" plain "%?"
      :if-new (file+head
               "%<%Y%m%d%H%M%S>-${slug}.org"
               ,(let ((options '("#+options: _:{}"
                                 "#+options: ^:{}"
                                 "#+startup: latexpreview"
                                 "#+startup: entitiespretty"
                                 "#+startup: inlineimages"
                                 "#+title: ${title}")))
                  (mapconcat 'identity options "\n")))
      :unnarrowed t)))
  (org-roam-node-display-template "${title}"))
#+end_src

***** Visualization UI For Org-Roam

#+begin_src emacs-lisp
(use-package org-roam-ui
  :requires (org-roam)
  :custom
  (org-roam-ui-sync-theme t)
  (org-roam-ui-follow t)
  (org-roam-ui-update-on-save t)
  (org-roam-ui-open-on-start nil))
#+end_src

***** Hydra: Org-Roam Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define+ org-hydra ()
    ("Org-Roam"
     (("l" org-roam-buffer-toggle "Toggle -> buffer" :toggle t)
      ("g" org-roam-graph         "Node <- display graph")
      ("f" org-roam-node-find     "Node <- find")
      ("i" org-roam-node-insert   "Node <- insert ':id' link")
      ("C" org-roam-capture       "Node <- Capture")))))
#+end_src

**** Citar: Cite Your Sources!

#+begin_src emacs-lisp
(use-package citar
  :hook ((LaTeX-mode org-mode) . citar-capf-setup)
  :custom (citar-bibliography '("~/Workspace/memorandum/references.bib")))
#+end_src

Also, allow =Embark= to interact with those citations.

#+begin_src emacs-lisp
(use-package citar-embark
  :requires (citar embark)
  :hook (org-mode . citar-embark-mode)
  :config (setq citar-at-point-function 'embark-act))
#+end_src

*** Haskell: Purely Functional

#+begin_src emacs-lisp
(use-package haskell-ts-mode
  :mode ("\\.hs\\(c\\|-boot\\)?\\'" . haskell-ts-mode)
  :hook (haskell-ts-mode . eglot-ensure)
  :config (with-eval-after-load 'eglot (haskell-ts-setup-eglot))
  :custom (haskell-ts-highlight-signature t))
#+end_src

**** Apheleia: Haskell Formatter

#+begin_src emacs-lisp
(with-eval-after-load 'apheleia
  (when (executable-find "fourmolu")
    (setf (alist-get 'fourmolu apheleia-formatters)
          '("fourmolu" "--stdin-input-file" "-"))
    (add-to-list 'apheleia-mode-alist '(haskell-ts-mode . fourmolu))))
#+end_src

**** Hydra: Haskell Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define haskell-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Langspec: Haskell ï½£â”€â”€" 'devicon "nf-dev-haskell")
            :color teal :quit-key "q")
    ("General"
     (("r" haskell-ts-run-haskell           "Open REPL")
      ("c" haskell-ts-compile-region-and-go "Code -> REPL"))))

  ;; :TODO| add when -ts- supports features.
  ;; ("h" haskell-hoogle                  "Hoogle")
  ;; "Action"
  ;; (("C" haskell-check                  "Check")
  ;;  ("c" haskell-compile                "Compile"))
  ;; "Cabal"
  ;; (("b" haskell-process-cabal-build    "Build")
  ;;  ("B" haskell-process-cabal          "Build +Flags"))

  (pretty-hydra-define+ editor-hydra ()
    ("Programming"
     (("h" (if (memq major-mode '(haskell-ts-mode))
               (haskell-hydra/body)
             (message "You are not in a Haskell buffer.")) "Haskell")))))
#+end_src

*** Kotlin: Language of Dem Android
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(use-package kotlin-ts-mode
  :mode (("\\.kt\\'" . kotlin-ts-mode)
         ("\\.kts\\'" . kotlin-ts-mode))
  :hook (kotlin-ts-mode . eglot-ensure))
#+end_src

**** Apheleia: Kotlin Formatter

#+begin_src emacs-lisp
(with-eval-after-load 'apheleia
  (when (executable-find "ktlint")
    (setf (alist-get 'ktlint apheleia-formatters)
          '("ktlint" "--log-level=none" "--stdin" "-F" "-"))
    (add-to-list 'apheleia-mode-alist '(kotlin-mode . ktlint))))
#+end_src

*** Lua: Embedded Scripting Language

#+begin_src emacs-lisp
(use-package lua-mode
  :mode ("\\.lua\\'" . lua-mode)
  :hook ((lua-mode lua-ts-mode) . eglot-ensure))
#+end_src

**** Apheleia: Lua Formatter

#+begin_src emacs-lisp
(with-eval-after-load 'apheleia
  (when (executable-find "stylua")
    (setf (alist-get 'stylua apheleia-formatters)
          '("stylua" "--config-path" (expand-file-name "~/.config/stylua/stylua.toml") "-"))
    (add-to-list 'apheleia-mode-alist '(lua-mode . stylua))))
#+end_src

*** Markdown: Minimal Markup Language

#+begin_src emacs-lisp
(use-package markdown-mode
  :mode ("\\.md\\'" . gfm-mode)
  :custom-face
  (markdown-header-face-1 ((t (:inherit markdown-header-face :height 1.25 :weight extra-bold))))
  (markdown-header-face-2 ((t (:inherit markdown-header-face :height 1.15 :weight bold))))
  (markdown-header-face-3 ((t (:inherit markdown-header-face :height 1.08 :weight bold))))
  (markdown-header-face-4 ((t (:inherit markdown-header-face :height 1.00 :weight bold))))
  (markdown-header-face-5 ((t (:inherit markdown-header-face :height 0.90 :weight bold))))
  (markdown-header-face-6 ((t (:inherit markdown-header-face :height 0.75 :weight extra-bold))))
  :custom (markdown-command "multimarkdown"))
#+end_src

**** Hydra: Markdown Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define markdown-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Langspec: Markdown ï½£â”€â”€" 'devicon "nf-dev-markdown")
            :color teal :quit-key "q")
    ("Interactive"
     (("d" markdown-do "Perform -> action"))))

  (pretty-hydra-define+ editor-hydra ()
    ("Markup"
     (("m" (if (eq major-mode 'markdown-mode)
               (markdown-hydra/body)
             (message "You are not in a markdown buffer.")) "Markdown")))))
#+end_src

*** Nix: Purely Functional DSL

#+begin_src emacs-lisp
(use-package nix-ts-mode
  :mode ("\\.nix\\'" . nix-ts-mode)
  :hook (nix-ts-mode . eglot-ensure))
#+end_src

**** Apheleia: Nix Formatter

#+begin_src emacs-lisp
(with-eval-after-load 'apheleia
  (when (executable-find "nixfmt")
    (add-to-list 'apheleia-mode-alist '(nix-ts-mode . nixfmt))))
#+end_src

*** Python: High Level Language

#+begin_src emacs-lisp
(use-package python-mode
  :mode ("\\.py\\'" . python-mode)
  :hook ((python-mode python-ts-mode) . eglot-ensure)
  :custom
  (python-shell-interpreter "ipython")
  (python-shell-interpreter-args "--simple-prompt"))
#+end_src

**** Apheleia: Python Formatter

#+begin_src emacs-lisp
(with-eval-after-load 'apheleia
  (when (executable-find "isort")
    (setf (alist-get 'isort apheleia-formatters)
          '("isort" "--profile black" "--stdout"))
    (add-to-list 'apheleia-mode-alist '(python-mode . isort)))

  (when (executable-find "black")
    (setf (alist-get 'black apheleia-formatters) '("black" "-"))
    (add-to-list 'apheleia-mode-alist '(python-mode . black))))
#+end_src

*** Rust: Statically & Strongly Typed

#+begin_src emacs-lisp
(use-package rust-mode
  :mode ("\\.rs\\'" . rust-mode)
  :hook ((rust-mode rust-ts-mode) . eglot-ensure)
  :init
  (require 'rust-mode) ;; Somehow it won't load anything...
  (add-to-list 'project-vc-extra-root-markers "Cargo.toml"))

(use-package cargo
  :requires (rust-mode)
  :hook ((rust-mode rust-ts-mode) . cargo-minor-mode))
#+end_src

Also, I would like to have the ability to interact with rust code-blocks defined within org-mode files.

#+begin_src emacs-lisp
(use-package ob-rust
  :requires (rust-mode)
  :after (ob))
#+end_src

**** Apheleia: Rust Formatter

#+begin_src emacs-lisp
(with-eval-after-load 'apheleia
  (when (executable-find "rustfmt")
    (setf (alist-get 'rustfmt apheleia-formatters)
          '("rustfmt" "--quiet" "--emit" "stdout"))
    (add-to-list 'apheleia-mode-alist '(rust-mode . rustfmt))))
#+end_src

**** Hydra: Rust Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define rust-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Langspec: Rust ï½£â”€â”€" 'devicon "nf-dev-rust")
            :color teal :quit-key "q")
    ("Actions"
     (("d" rust-promote-module-into-dir "Module -> Dir")
      ("p" rust-playpen-region          "Region -> Playground")
      ("P" rust-playpen-buffer          "Buf -> Playground"))
     "Build"
     (("r" rust-run                     "Run Project")
      ("R" rust-run-releae              "Run Release")
      ("t" rust-test                    "Tests Project")
      ("l" rust-run-clippy              "Run Clippy")
      ("c" rust-compile                 "Compile")
      ("C" rust-compile-release         "Compile Release")
      ("e" rust-check                   "Check for Errors"))
     "Cargo"
     (("a" cargo-process-add            "Add")
      ("x" cargo-process-rm             "Delete")
      ("c" cargo-process-clean          "Clean")
      ("h" cargo-process-doc            "Docs")
      ("u" cargo-process-update         "Update"))))

  (pretty-hydra-define+ editor-hydra ()
    ("Programming"
     (("r" (if (memq major-mode '(rust-mode rust-ts-mode))
               (rust-hydra/body)
             (message "You are not in a rust buffer.")) "Rust")))))
#+end_src

*** Typst: A More Powerful LaTeX Alt.

#+begin_src emacs-lisp
(use-package typst-ts-mode
  :ensure (:host sourcehut :repo "meow_king/typst-ts-mode")
  :mode ("\\.typ\\'" . typst-ts-mode)
  :hook (typst-ts-mode . (lambda ()
                           (when (executable-find "typst-lsp")
                             (add-to-list 'eglot-server-programs "typst-lsp")
                             (eglot-ensure))))
  :config
  (with-eval-after-load 'consult-imenu
    (setq consult-imenu-config
          (append consult-imenu-config '((typst-ts-mode
                                          :topLevel "Headings"
                                          :types ((?h "Headings" typst-ts-markup-header-face)))))))
  :custom
  (typst-ts-mode-watch-options "--open")
  (typst-ts-mode-enable-raw-blocks-highlight t)
  (typst-ts-mode-highlight-raw-blocks-at-startup t
                                                 (?f "Functions" font-lock-function-name-face)))
#+end_src

**** Apheleia: Typst Formatter

#+begin_src emacs-lisp
(with-eval-after-load 'apheleia
  (when (executable-find "typstyle")
    (setf (alist-get 'typstyle apheleia-formatters) '("typstyle"))
    (add-to-list 'apheleia-mode-alist '(typst-ts-mode . typstyle))))
#+end_src

**** Hydra: Typst Bindings

#+begin_src emacs-lisp
(with-eval-after-load 'pretty-hydra
  (pretty-hydra-define typst-hydra
    (:title (pretty-hydra-title "â”€â”€ï½¢ Langspec: Typst ï½£â”€â”€" 'mdicon "nf-md-math_compass")
            :color teal :quit-key "q")
    ("Build"
     (("c" typst-ts-mode-compile "Compile")
      ("p" typst-ts-mode-preview "Preview")
      ("u" typst-ts-mode-compile-and-preview "Run & Preview"))))

  (pretty-hydra-define+ editor-hydra ()
    ("Markup"
     (("t" (if (eq major-mode 'typst-ts-mode)
               (typst-hydra/body)
             (message "You are not in a typst buffer."))  "Typst")))))
#+end_src

*** Zig: Imperative & Statically Compiled
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

#+begin_src emacs-lisp
(use-package zig-mode
  :mode ("\\.zig\\'" . zig-mode)
  :hook ((zig-mode zig-ts-mode) . eglot-ensure))
#+end_src

**** Apheleia: Zig Formatter

#+begin_src emacs-lisp
(with-eval-after-load 'apheleia
  (when (executable-find "zig")
    (setf (alist-get 'zigfmt apheleia-formatters) '("zig" "fmt" "--stdin"))
    (add-to-list 'apheleia-mode-alist '(zig-mode . zigfmt))))
#+end_src

** Part 6: Concluding Our Endless Package Hunt!

#+begin_src emacs-lisp
;;; init.el ends here
#+end_src
