#+title: Just a Literate Emacs Configuration
#+author: Icy-Thought
#+STARTUP: showeverything

#+NAME: irkalla-emacs.png
#+CAPTION: Showcasing my very first standalone Emacs configuration.
[[../.github/assets/png/irkalla.png]]

* Embarking on the Irkalla Journey: Initialization.

** Part 1: Exploring The Feasibility of Emacs

*** Tweaking Built-in Aesthetics & Functionality

**** Display Pop-up Windows, Instead of Mini-Buffer

#+begin_src emacs-lisp
(use-package posframe
  :defer t
  :custom (posframe-mouse-banish '(0 . 5000)))
#+end_src

**** Window Zoom on Demand -> "Full-screen"

#+begin_src emacs-lisp
(use-package winner
  :elpaca nil
  :hook (elpaca-after-init . winner-mode)
  :general
  (irkalla/comma-lead-keydef
   "z"   '(:ignore t            :which-key "Winner Mode")
   "z p" '(delete-other-windows :which-key "Win -> Zoom-in")
   "z u" '(winner-undo          :which-key "Undo Winner")
   "z r" '(winner-undo          :which-key "Redo Winner")))
#+end_src

*** Unraveling a Multitude of Options

**** Identify yourself; who are you???

#+begin_src emacs-lisp
(setq user-full-name "Icy-Thought"
      user-mail-address "icy-thought@pm.me")
#+end_src

**** Rational Irkalla Emacs Behaviour

#+begin_src emacs-lisp
(use-package emacs
  :elpaca nil
  :custom
  (backward-delete-char-untabify-method 'hungry)
  (cursor-in-non-selected-windows nil)
  (dired-kill-when-opening-new-dired-buffer t)
  (echo-keystrokes 0.02)
  (enable-recursive-minibuffers t)
  (help-window-select t)
  (read-buffer-completion-ignore-case t)
  (read-process-output-max (* 64 1024));
  (ring-bell-function 'ignore))
#+end_src

Reducing debug output is always desirable, unless we ask for a verbose debugging log!

#+begin_src emacs-lisp
(setq debug-on-error init-file-debug
      jka-compr-verbose init-file-debug)
#+end_src

***** Scroll-bar & Scrolling Behaviour

#+begin_src emacs-lisp
(use-package emacs
  :elpaca nil
  :hook (elpaca-after-init . pixel-scroll-precision-mode)
  :custom
  (auto-window-vscroll nil)
  (fast-but-imprecise-scrolling nil)
  (hscroll-margin 1)
  (hscroll-step 1)
  (lazy-lock-defer-on-scrolling t)
  (mouse-wheel-progressive-speed nil)
  (mouse-wheel-scroll-amount '(1 ((shift) . 1)))
  (scroll-conservatively 101)
  (scroll-down-aggressively 0.01)
  (scroll-margin 3)
  (scroll-preserve-screen-position t)
  (scroll-step 1)
  (scroll-up-aggressively 0.01))
#+end_src

**** hl-line: Highlight Cursor-line

#+begin_src emacs-lisp
(use-package hl-line
  :elpaca nil
  :hook (elpaca-after-init . global-hl-line-mode))
#+end_src

**** Auto-revert: Update Inactive Files on-change

#+begin_src emacs-lisp
(use-package auto-revert
  :elpaca nil
  :hook ((prog-mode text-mode) . auto-revert-mode)
  :custom
  (auto-revert-interval 1)
  (auto-revert-notify t)
  (auto-revert-verbose t))
#+end_src

**** Time: Correcting The Time-Zone

#+begin_src emacs-lisp
(use-package time
  :elpaca nil
  :defer t
  :custom
  (display-time-24hr-format t)
  (display-time-day-and-date t))
#+end_src

** Part 2: Experimenting With Miraculous Pkgs

*** Unleashing the Power of UI Extensions

**** HTMLize: Decorate Buffer Text With HTML

Without ~htmlize~ =Ement.el= fails to decorate our /src-blocks/ properly. Thus it is required of us to add it to our package
list to apply the appropriate decorations where necessary for an aesthetically pleasing =Ement= buffer.

#+begin_src emacs-lisp
(use-package htmlize
  :defer t)
#+end_src

*** Building a Versatile Toolbox

**** Consult: Consulting completing-read

#+begin_src emacs-lisp
(use-package consult
  :hook (completion-list-mode . consult-preview-at-point-mode)
  :general
  <<consult-bindings>>
  :config
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)
  (advice-add #'register-preview :override #'consult-register-window)
  ;; Consult -> select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)
  :custom
  (consult-narrow-key "<") ;; "C-+"

  (consult-customize
   consult-theme :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   :preview-key '(:debounce 0.4 any)))
#+end_src

To reduce the burden of recalling all bindings, let's rewrite some of them to match our previous Neovim setup.

#+NAME: consult-bindings
#+begin_src emacs-lisp :tangle no
(irkalla/space-lead-keydef
  "/"          '(consult-ripgrep        :which-key "Quick RegExp grep")
  "b b"        '(consult-buffer         :which-key "Switch -> buffer")

  "p b"        '(consult-project-buffer :which-key "Switch -> project buffer")
  "p /"        '(consult-git-grep       :which-key "Grep .git repostiory")

  "f f"        '(consult-find           :which-key "File in Project")
  "f r"        '(consult-recent-file    :which-key "Recent files")

  ;; LSP-related
  "l"          '(:ignore t              :which-key "LSP & Editing")
  "l m"        '(consult-mark           :which-key "Jump -> marker")
  "l M"        '(consult-global-mark    :which-key "Glob. jump -> marker")
  "l o"        '(consult-outline        :which-key "Jump -> buffer outlines")
  "l ["        '(consult-flymake        :which-key "Jump -> Flymake diagnostics")
  "l ]"        '(consult-compile-error  :which-key "Jump -> compile-error in buffer"))

(irkalla/comma-lead-keydef
  "c"            '(:ignore t                   :which-key "Consult")
  "c b"          '(consult-bookmark            :which-key "Open named bookmark")
  "c h"          '(consult-history             :which-key "Insert string from hist.")
  "c k"          '(consult-kmacro              :which-key "Run KBD macro")
  "c ?"          '(consult-man                 :which-key "MAN-page str search")
  "c /"          '(consult-info                :which-key "MANUALS text search")
  "c p"          '(consult-yank-pop            :which-key "Paste yanks -> cursor")
  "c t"          '(consult-theme               :which-key "Select available themes")
  "c <return>"   '(consult-mode-command        :which-key "Run command")
  "c S-<return>" '(consult-complex-command     :which-key "Evaluate CMD from hist.")
  "c w"          '(consult-buffer-other-window :which-key "Frame buffer switch"))
#+end_src

Might as-well have consult integrate itself to our projectile and display existing files in current project directory.

#+begin_src emacs-lisp
(use-package consult-projectile
  :after projectile
  :general
  (irkalla/space-lead-keydef
    "p p" '(consult-projectile-switch-project :which-key "Switch Project")))
#+end_src

**** Eldoc: Document Things at Point

#+begin_src emacs-lisp
(use-package eldoc
  :elpaca nil
  :custom
  (eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)
  (eldoc-echo-area-display-truncation-message nil)
  (eldoc-echo-area-use-multiline-p nil)
  (eldoc-echo-area-prefer-doc-buffer t)
  (eldoc-idle-delay 1.0))
#+end_src

Having our Eldoc stuck in mini-buffer is not desirable, therefore it ought to be moved into its own posframe!

#+begin_src emacs-lisp
(use-package eldoc-box
  :after eldoc
  :general (:states '(normal operator) :keymaps 'prog-mode-map
             "TAB" '(eldoc-box-help-at-point :which-key "LSP info at point")))
#+end_src

**** Embark: Mini-Buffer Actions Rooted in Keymaps

#+begin_src emacs-lisp
(use-package embark
  :hook (eldoc-documentation-functions . embark-eldoc-first-target)
  :general
  <<embark-bindings>>
  :custom
  (embark-prompter #'embark-completing-read-prompter)
  (embark-indicators '(embark-minimal-indicator
                       embark-highlight-indicator
                       embark-isearch-highlight-indicator))
  :config
  (setq prefix-help-command #'embark-prefix-help-command)
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
#+end_src

Might as well add several bindings to our Embark.

#+NAME: embark-bindings
#+begin_src emacs-lisp :tangle no
(irkalla/comma-lead-keydef
  "e"   '(:ignore t       :which-key "Embark")
  "e a" '(embark-act      :which-key "Prompt for action -> perform")
  "e d" '(embark-dwim     :which-key "Run default action -> buffer")
  "e h" '(embark-bindings :which-key "Explore Emacs bindings"))
#+end_src

Integrating Embark with our consult package.

#+begin_src emacs-lisp
(use-package embark-consult
  :after (embark consult)
  :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

**** Version Control: Magit + Blamer + Git-Gutter

***** Magit: A Magic Wand for Git

#+begin_src emacs-lisp
(use-package magit
  :defer t
  :if (executable-find "git")
  :general
  <<magit-bindings>>
  :custom
  (magit-auto-revert-mode nil)
  (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
#+end_src

Appending bindings to our Magit configuration.

#+NAME: magit-bindings
#+begin_src emacs-lisp :tangle no
(irkalla/space-lead-keydef
  "g"   '(:ignore t :which-key "Magit")
  "g g" '(magit :which-key "Open Magit!"))
#+end_src

Display the ~TODO~'s of our Git repository in the Magit buffer. Useful for reducing the burden of grepping all the ~TODO~'s
and later deciding which one to hop-on to.

#+begin_src emacs-lisp
(use-package magit-todos
  :hook (magit-mode . magit-todos-mode)
  :custom
  (magit-todos-recursive t)
  (magit-todos-depth 10)
  (magit-todos-exclude-globs '(".git/" "*.html"))
  (magit-todos-nice (if (executable-find "nice") t nil))
  (magit-todos-scanner #'magit-todos--scan-with-rg)
  :config
  (custom-set-variables
   '(magit-todos-keywords (list "TODO" "FIXME" "HACK"))))
#+end_src

***** Blamer: Blame our Git Repository

#+begin_src emacs-lisp
(use-package blamer
  :defer t
  :custom
  (blamer-idle-time 0.5)
  (blamer-min-offset 70)
  (blamer-view 'overlay-right)
  (blamer-type 'visual)
  (blamer-max-commit-message-length 70)
  (blamer-force-truncate-long-line nil)
  (blamer-author-formatter " ✎ %s ")
  (blamer-commit-formatter "● \'%s\' ● ")
  :custom-face
  (blamer-face ((t (:background nil :height 125 :italic t)))))
#+end_src

***** Git-Gutter: Symbols to Highlight Git-related Changes

#+begin_src emacs-lisp
(use-package git-gutter
  :diminish git-gutter-mode
  :hook (prog-mode . git-gutter-mode)
  :custom (git-gutter:update-interval 0.05))
#+end_src

Replacing ~Git-Gutter~ symbols with appropriate vertical lines (fringes) appears to be a saner alternative to the default
symbols which comes with the package.

#+begin_src emacs-lisp
(use-package git-gutter-fringe
  :config
  (define-fringe-bitmap 'git-gutter-fr:added [224] nil nil '(center repeated))
  (define-fringe-bitmap 'git-gutter-fr:modified [224] nil nil '(center repeated))
  (define-fringe-bitmap 'git-gutter-fr:deleted [128 192 224 240] nil nil 'bottom))
#+end_src

**** PDF-Tools: A Quick PDF Viewer

#+begin_src emacs-lisp
(use-package pdf-tools
  :elpaca nil ;; <-^ fetched from Nixpkgs
  :config (push 'pdf-tools elpaca-ignored-dependencies))
#+end_src

Make sure that our PDF’s are displayed with darker colors.

#+begin_src emacs-lisp
(use-package pdf-view
  :elpaca nil
  :after pdf-tools
  :magic ("%PDF" . pdf-view-mode)
  :mode ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
  :hook (pdf-view-mode . (lambda ()
                           ;; :NOTE| Set the PDF free from the unnecessary borders
                           (set (make-local-variable 'evil-normal-state-cursor) (list nil))
                           (pdf-view-themed-minor-mode)))
  :config
  (define-advice pdf-view-enlarge (:after (&rest _args) center-after-enlarge)
    "Center the PDF view in the active PDF window after enlarging it."
   (pdf-view-center-in-window))

  (define-advice pdf-view-shrink (:after (&rest _args) center-after-shrink)
    "Center the PDF view in the active PDF window after shrinking it."
    (pdf-view-center-in-window))
  :custom
  (pdf-view-use-scaling t)
  (pdf-view-use-imagemagick nil)
  (pdf-view-display-size 'fit-width))
#+end_src

We also want to jump back to the last known position after opening a PDF file.

#+begin_src emacs-lisp
(use-package pdf-view-restore
  :hook (pdf-view-mode . pdf-view-restore-mode)
  :custom (pdf-view-restore-filename (no-littering-expand-var-file-name "pdf-view-restore")))
#+end_src

**** NOV: A Customizable EPUB Reader

#+begin_src emacs-lisp
(use-package nov
  :mode ("\\.epub\\'" . nov-mode)
  :hook (nov-mode . (lambda ()
                      (olivetti-mode +1)
                      (visual-line-mode +1)
                      (visual-fill-column-mode +1)))
  :general
  <<nov-bindings>>
  :custom-face
  (shr-text ((t (:inherit variable-pitch-face :height 1.05))))
  (shr-h1   ((t (:height 1.54 :slant italic))))
  (shr-h2   ((t (:height 1.25 :slant italic))))
  (shr-h3   ((t (:height 1.15 :slant italic))))
  (shr-h4   ((t (:height 1.12 :slant italic))))
  (shr-h5   ((t (:height 1.09 :slant italic))))
  (shr-h6   ((t (:height 1.06 :slant italic))))

  :custom
  (nov-text-width t)
  (nov-text-width 120))
#+end_src

Defining bindings for our precious =Nov-Mode= to reduce the burden of navigation OTB.

#+NAME: nov-bindings
#+begin_src emacs-lisp :tangle no
(:states 'normal :keymaps 'nov-mode-map
  "H"   '(nov-previous-document   :which-key "Go -> previous doc")
  "L"   '(nov-previous-document   :which-key "Go -> next doc")
  "d"   '(nov-scroll-down         :which-key "Scroll downwards")
  "u"   '(nov-scroll-up           :which-key "Scroll upwards")
  "gm"  '(nov-display-metadata    :which-key "Show Metadata")
  "gr"  '(nov-render-document     :which-key "Render document")
  "o"   '(nov-goto-toc            :which-key "Table of contents")
  "gv"  '(nov-view-source         :which-key "View source")
  "gV"  '(nov-view-content-source :which-key "View content source"))
#+end_src

Allow ~NOV~ to display cleaner (+themed) EPUB files when launched.

#+begin_src emacs-lisp
(use-package nov-xwidget
  :elpaca (:host github :repo "chenyanming/nov-xwidget")
  :after nov
  :hook (nov-mode . nov-xwidget-inject-all-files)
  :general (:states 'normal :keymaps 'nov-mode-map
             "x" '(nov-xwidget-view :which-key "Open EPUB -> Nov-Mode")))
#+end_src

**** VTerm: A Quick Terminal Emulator

#+begin_src emacs-lisp
(use-package vterm
  :elpaca nil
  :hook (vterm-mode . (lambda () (setq-local global-hl-line-mode nil)))
  :general
  <<vterm-bindings>>
  :custom
  (vterm-timer-delay 0.01)
  (vterm-max-scrollback 10000)
  (vterm-clear-scrollback-when-clearing t))
#+end_src

Binding our VTerm for quicker access to the terminal.

#+NAME: vterm-bindings
#+begin_src emacs-lisp :tangle no
(:states 'insert :keymaps 'vterm-mode-map
  "<S-prior>" #'scroll-down-command
  "<S-next>"  #'scroll-up-command)

(irkalla/space-lead-keydef
  "t"   '(:ignore t    :which-key "Terminal")
  "t t" '(vterm-toggle :which-key "Open VTerm"))

(irkalla/comma-lead-keydef
  "t"   '(:ignore t       :which-key "Terminal")
  "t c" '(vterm-copy-mode :which-key "Terminal -> read-only"))
#+end_src

#+begin_src emacs-lisp
(use-package vterm-toggle
  :after vterm
  :custom
  (vterm-toggle-fullscreen-p nil)
  (vterm-toggle-use-dedicated-buffer t))
#+end_src

**** Vertico: Vertical Interactive Completion

#+begin_src emacs-lisp
(use-package vertico
  :elpaca (:files (:defaults "extensions/*"))
  :hook (elpaca-after-init . vertico-mode)
  :custom
  (vertico-cycle t)
  <<vertico-multiform>>)
#+end_src

Controlling =Vertico='s behaviour in several forms has oftentimes proven to be rather useful!

#+NAME: vertico-multiform
#+begin_src emacs-lisp :tangle no
(vertico-multiform-categories
 '((file grid reverse)
   (consult-location buffer)
   (consult-grep buffer)
   (minor-mode reverse)
   (imenu buffer)
   (t unobtrusive)))

(vertico-multiform-commands
  '((consult-dir reverse)
    (execute-extended-command flat)
    (embark-prefix-help-command reverse)
    (completion-at-point reverse)))
#+end_src

Displaying our ~Vertico~ instances in their respective pop-up window would've been preferable.

#+begin_src emacs-lisp :tangle no
(use-package vertico-posframe
  :after vertico
  :hook (vertico-mode . vertico-posframe-mode)
  :custom
  (vertico-posframe-poshandler #'posframe-poshandler-frame-top-center)
  (vertico-posframe-fallback-mode vertico-buffer-mode))
#+end_src

Allowing our mouse to behave as expected when used in ~Vertico~.

#+begin_src emacs-lisp
(use-package vertico-mouse
  :elpaca nil
  :after vertico
  :hook (vertico-mode . vertico-mouse-mode))
#+end_src

Correcting navigation behaviour when interacting with directories in ~Vertico~.

#+begin_src emacs-lisp
(use-package vertico-directory
  :elpaca nil
  :after vertico
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)
  :general (:keymaps 'vertico-map
             "RET"   #'vertico-directory-enter
             "DEL"   #'vertico-directory-delete-char
             "M-DEL" #'vertico-directory-delete-word))
#+end_src

Let's enhances the behavior & appearance of Emacs mini-buffer prompt:
1. Add a prompt indicator to the completing-read-multiple function
2. Make prompt read-only
3. Hides cursor within prompt
4. Prevents cursor from being placed inside prompt

#+begin_src emacs-lisp
(use-package emacs
  :elpaca nil
  :preface
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" "" crm-separator)
                  (car args))
          (cdr args)))
  :hook (minibuffer-setup . cursor-intangible-mode)
  :config
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt)))
#+end_src

**** Marginalia: Mini-buffer Annotations

#+begin_src emacs-lisp
(use-package marginalia
  :hook (elpaca-after-init . marginalia-mode)
  :custom
  (marginalia-max-relative-age 0)
  (marginalia-align 'right))
#+end_src

*** Integrating Social Necessities to Irkalla

**** Ement: A Superior Matrix Client

#+begin_src emacs-lisp
(use-package ement
  :hook (ement-room-mode . olivetti-mode)
  :custom
  ;; :NOTE| Notifications ought to be limited to @mentions only!
  (ement-notify-notification-predicates '(ement-notify--event-mentions-session-user-p
                                          ement-notify--event-mentions-room-p))
  (ement-room-images t)
  (ement-room-message-format-spec "%S>%L %B%r%R[%t]")
  (ement-room-send-message-filter #'ement-room-send-org-filter)
  (ement-save-sessions t))
#+end_src

A ~defun~ is required for us to launch a seperate scratchpad buffer for =Ement.el=!

#+begin_src emacs-lisp
(defun irkalla/connect-to-matrix ()
  "Connect Emacs to the Matrix, unless connection exists."
  (interactive)
  (require 'ement)
  (let* ((matrix-username "@gilganix:matrix.org"))
    (cond
      ((map-elt ement-sessions matrix-username)
       (ement-room-list))
      ((ement--read-sessions)
       (call-interactively #'ement-connect))
      (t (ement-connect
          :user-id matrix-username
          :password (irkalla/read-secret-file "ement")
          :uri-prefix "http://localhost:8009")))))
#+end_src

**** Telega: A Telegram Client for Emacs (disabled)

#+begin_src emacs-lisp
(use-package telega
  :elpaca nil ;; <-^ fetched from Nixpkgs
  :defer 2)
#+end_src

*** Supercharging Irkalla's Mobility

**** Perspective: An Emacs Workspace Manager

#+begin_src emacs-lisp
(use-package perspective
  :hook (elpaca-after-init . persp-mode)
  :custom (persp-mode-prefix-key (kbd "C-c M-p")))
#+end_src

*** Tailoring our Editing Experience


*** Step-1: A More Efficient Completion System

**** Corfu: Completion in Region

#+begin_src emacs-lisp
(use-package corfu
  :elpaca (:files (:defaults "extensions/*.el"))
  :preface
  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active)
                (bound-and-true-p vertico--input)
                (eq (current-local-map) read-passwd-map))
      (setq-local corfu-echo-delay nil
                  corfu-popupinfo-delay nil)
      (corfu-mode 1)))
  :hook ((elpaca-after-init . global-corfu-mode)
         (minibuffer-setup . corfu-enable-always-in-minibuffer))
  :general (:states 'insert :keymaps 'corfu-map
            "TAB"   #'corfu-next
            [tab]   #'corfu-next
            "S-TAB" #'corfu-previous
            [backtab] #'corfu-previous)
  :custom
  (corfu-auto t)
  (corfu-cycle t)
  (corfu-preselect t)
  (corfu-auto-prefix 1)
  (corfu-auto-delay 0.05)
  (corfu-count 16)
  (corfu-scroll-margin 5)
  (corfu-separator ?\s)
  (corfu-on-exact-match nil)
  (corfu-preview-current 'insert)
  (corfu-quit-no-match 'separator))
#+end_src

Completion at point is necessary for Corfu to work its wonders as a completion system!

#+begin_src emacs-lisp
(use-package cape
  :config
  (dolist (fn '(cape-file cape-dabbrev cape-symbol cape-tex cape-keyword))
    (add-to-list 'completion-at-point-functions fn)))
#+end_src

Completions should display icons for their respective types.

#+begin_src emacs-lisp
(use-package kind-icon
  :after (svg-lib corfu)
  :custom
  (kind-icon-default-face 'corfu-default)
  ;; :NOTE| Changing the color of our icons
  (kind-icon-blend-background nil)
  (kind-icon-blend-frac 0.08)
  :config (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))
#+end_src

~Corfu~ should also display its completions in a floating window.

#+begin_src emacs-lisp
(use-package corfu-popupinfo
  :elpaca nil
  :hook (corfu-mode . corfu-popupinfo-mode)
  :custom (corfu-popupinfo-delay '(0.5 . 0.2)))
#+end_src

~Corfu~ should also function inside our Emacs terminals.

#+begin_src emacs-lisp
(use-package corfu-terminal
  :unless window-system
  :hook (corfu-mode . corfu-terminal-mode))
#+end_src

**** ChatGPT: Trained Machine Learning System (disabled)

#+begin_src emacs-lisp :tangle no
(use-package chatgpt-shell
  :general
  (irkalla/comma-lead-keydef
    "o c" '(chatgpt-shell :which-key "Open ChatGPT")
    "o d" '(dall-e-shell  :which-key "Open DALL-E"))
  :custom (chatgpt-shell-openai-key (lambda () (irkalla/read-secret-file "closedAI"))))
#+end_src

*** Step-2: LSP, Diagnostics & Syntax Highlighting!

#+begin_src emacs-lisp
(use-package emacs
  :elpaca nil
  :custom
  (compilation-always-kill t)
  (compilation-ask-about-save nil)
  (compilation-scroll-output t)
  (compilation-scroll-output t)

  (completion-ignore-case t)
  (completions-detailed t)

  (read-file-name-completion-ignore-case t)
  (tab-always-indent 'completion)
  (tab-first-completion 'word-or-paren-or-punct))
#+end_src

**** Apheleia: Asynchronous Code Formatter

#+begin_src emacs-lisp
(use-package apheleia
  :diminish apheleia-mode
  :preface
  (defun irkalla/apheleia-disable-formatting ()
    "When triggered -> disable apheleia formatting on save."
    (interactive)
    (remove-hook 'before-save-hook 'eglot-format-buffer t)
    (apheleia-mode -1))
  :hook (prog-mode . apheleia-mode)
  :general
  (irkalla/comma-lead-keydef
    "l"   '(:ignore t                           :which-key "LSP")
    "l d" '(irkalla/apheleia-disable-formatting :which-key "Disable Auto-format"))
  :config
  <<apheleia-custom-formatters>>)
 #+end_src

***** Self-defined Code Formatting Actions
:PROPERTIES:
:header-args+: :tangle no
:END:

#+NAME: apheleia-custom-formatters
#+begin_src emacs-lisp
<<apheleia-lang-haskell>>
<<apheleia-lang-nix>>
<<apheleia-lang-python>>
<<apheleia-lang-rust>>
#+end_src

****** Haskell: intelligent, but rather lazy..

#+NAME: apheleia-lang-haskell
#+begin_src emacs-lisp
(when (executable-find "stylish-haskell")
  (push '(stylish-haskell . ("stylish-haskell" "-"))
        apheleia-formatters)

  (setf (alist-get 'haskell-mode apheleia-mode-alist)
        '(stylish-haskell)))
#+end_src

****** Nix-Lang: stuck in a perfectionist's loop

#+NAME: apheleia-lang-nix
#+begin_src emacs-lisp
(when (executable-find "alejandra")
  (push '(alejandra . ("alejandra" "--quiet" "-"))
        apheleia-formatters)

  (setf (alist-get 'nix-mode apheleia-mode-alist)
        '(alejandra)))
#+end_src

****** Python: the odd ball who keeps growing

#+NAME: apheleia-lang-python
#+begin_src emacs-lisp
(when (executable-find "isort")
  (push '(isort . ("isort" "--profile" "black" "--stdout" "-"))
        apheleia-formatters)

  (setf (alist-get 'python-mode apheleia-mode-alist)
        '(isort black)))
#+end_src

****** Rust: wanna-be functional, but too literal

#+NAME: apheleia-lang-rust
#+begin_src emacs-lisp
(when (executable-find "rustfmt")
  (push '(rustfmt . ("rustfmt" "--quiet" "--emit" "stdout"))
        apheleia-formatters)

  (setf (alist-get 'rust-mode apheleia-mode-alist)
        '(rustfmt)))
#+end_src

**** Orderless: Completion That Matches Multiple Regexp

#+begin_src emacs-lisp
(use-package orderless
  :after vertico
  :custom
  (completion-styles '(orderless))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles  . (orderless flex)))
                                   (eglot (styles . (orderless flex))))))
#+end_src

**** Eglot: Language Server Protocol

#+begin_src emacs-lisp
(use-package eglot
  :elpaca nil
  :general
  (irkalla/space-lead-keydef
    :states 'normal :keymaps 'eglot-mode-map
    "l a"    '(eglot-code-actions    :which-key "Perform code-actions")
    "l r"    '(eglot-rename          :which-key "Rename $SYMB")
    "l f"    '(eglot-format          :which-key "Format buffer")
    "l ?"    '(xref-find-references  :which-key "Find -> references")
    "l d"    '(xref-find-definitions :which-key "Find -> definition")
    "l /"    '(xref-find-apropos     :which-key "Find $SYMB <- pattern"))
  :custom
  (eglot-autoshutdown t)
  (eglot-confirm-server-initiated-edits nil)
  (eglot-extend-to-xref t)
  (eglot-ignored-server-capabilities '(:documentHighlightProvider))
  (eglot-menu-string "LSP"))
#+end_src

**** Sideline: Minimal UI for LSP Diagnostics

#+begin_src emacs-lisp
(use-package sideline
  :custom
  (sideline-delay 0.2)
  (sideline-display-backend-name nil)
  (sideline-display-backend-type 'inner))
#+end_src

**** Jinx: Fast Spell Checker

#+begin_src emacs-lisp
(use-package jinx
  :elpaca nil
  :hook (text-mode . jinx-mode)
  :general
  (:states 'normal :keymaps '(prog-mode-map text-mode-map)
    "z =" '(jinx-correct :which-key "Correct damned misspellings...")))
#+end_src

**** Flymake: Built-in Syntax Checker

#+begin_src emacs-lisp
(use-package flymake
  :elpaca nil
  :hook (prog-mode . flymake-mode)
  :custom
  ;; (flymake-show-diagnostics-at-end-of-line t) <- way to much info..
  (flymake-fringe-indicator-position 'right-fringe)
  (elisp-flymake-byte-compile-load-path load-path))
#+end_src

Extending the diagnostic ability of ~Flymake~ to support an additional set of language tools.

#+begin_src emacs-lisp
(use-package flymake-collection
  :after flymake
  :hook (flymake-mode . flymake-collection-hook-setup))

;; :NOTE| Appending :flymake-hook to the keywords of use-package!
(elpaca-wait)
#+end_src

Preventing ~Eglot~ from interfering with our ~Flymake~ diagnostics is preferable.

#+begin_src emacs-lisp
(with-eval-after-load "eglot"
 (add-to-list 'eglot-stay-out-of 'flymake)
 (add-hook 'flymake-diagnostic-functions 'eglot-flymake-backend))
#+end_src

***** Sideline: Display Flymake Diagnostics on Hover

#+begin_src emacs-lisp
(use-package sideline-flymake
  :hook (flymake-mode  . sideline-mode)
  :custom (sideline-backends-right '((sideline-flymake  . down))))
#+end_src

**** Tree-Sitter: Quicker Syntax Highlighting + More!

#+begin_src emacs-lisp
(use-package tree-sitter
  :hook ((prog-mode . global-tree-sitter-mode)
         (tree-sitter-after-on . tree-sitter-hl-mode)))
#+end_src

***** Combobulate: Structured Editing & Navigation

#+begin_src emacs-lisp
(use-package combobulate
  :elpaca (:host github :repo "mickeynp/combobulate")
  :hook (tree-sitter-after-on . combobulate-mode)
  :general
  (irkalla/space-lead-keydef
    "l c" '(combobulate :which-key "Combobulate")))
#+end_src

***** TS-fold: Folding Code-blocks Like Origami

#+begin_src emacs-lisp
(use-package ts-fold
  :elpaca (:host github :repo "emacs-tree-sitter/ts-fold")
  :hook (prog-mode . ts-fold-mode))
#+end_src

*** Step-3: Language-specific Adjustments

**** Emacs-Lisp: Controlling Wild Lisp Brackets

#+begin_src emacs-lisp
(use-package parinfer-rust-mode
  :hook (emacs-lisp-mode . (lambda ()
                             (electric-pair-mode -1)
                             (parinfer-rust-mode)))
  :custom
  (parinfer-rust-auto-download t)
  (parinfer-rust-library-directory (no-littering-expand-var-file-name "parinfer-rust/")))
#+end_src

**** Haskell: Lazy & Statically Typed FP Language

#+begin_src emacs-lisp
(use-package haskell-mode
  :mode ("\\.hs\\'" . haskell-mode)
  :hook (haskell-mode . eglot-ensure)
  :config
  (setq eglot-workspace-configuration
        '((haskell (formattingProvider "stylish-haskell")))))
#+end_src

**** Markdown: Simple Markup Language

#+begin_src emacs-lisp
(use-package markdown-mode
  :mode ("\\.md\\'" . gfm-mode)
  :general
  (irkalla/comma-lead-keydef markdown-mode-map
    "m d"    '(markdown-do :which-key "Perform -> action"))
  :custom-face
  (markdown-header-face-1 ((t (:inherit markdown-header-face :height 1.25 :weight extra-bold))))
  (markdown-header-face-2 ((t (:inherit markdown-header-face :height 1.15 :weight bold))))
  (markdown-header-face-3 ((t (:inherit markdown-header-face :height 1.08 :weight bold))))
  (markdown-header-face-4 ((t (:inherit markdown-header-face :height 1.00 :weight bold))))
  (markdown-header-face-5 ((t (:inherit markdown-header-face :height 0.90 :weight bold))))
  (markdown-header-face-6 ((t (:inherit markdown-header-face :height 0.75 :weight extra-bold))))
  :custom (markdown-command "multimarkdown"))
#+end_src

**** Nix: Dynamic Typed FP Language Used in NixOS

#+begin_src emacs-lisp
(use-package nix-mode
  :mode ("\\.nix\\'" . nix-mode)
  :hook (nix-mode . eglot-ensure)
  :config
  (with-eval-after-load 'eglot
   (add-to-list 'eglot-server-programs '(nix-mode . ("nil")))))
#+end_src

**** Org-Mode: The Superior File-format

#+begin_src emacs-lisp
(use-package org
  :elpaca nil
  :defer t
  :preface
  (defun irkalla/org-electric-dollar ()
    "Inserts \\( \\) when $, and replaces it with \\[ \\] when $$."
    (interactive)
    (if (and (looking-at "\\\\)")
             (looking-back "\\\\("))
        (progn (delete-char 2)
               (delete-char -2)
               (insert "\\[\\]"))
      (insert "\\(\\)")
      (backward-char 2)))
  :hook (org-mode . org-display-inline-images)
  :general
  (:states 'insert :keymaps 'org-mode-map
    "$" #'irkalla/org-electric-dollar)

  (irkalla/comma-lead-keydef
    "o"   '(:ignore t        :which-key "Org-Mode")
    "o e" '(org-edit-special :which-key "Edit -> special buffer")
    "o t" '(org-babel-tangle :which-key "Tangle buffer"))
  :custom-face
  (org-document-title ((t (:height 1.50))))
  (org-level-1        ((t (:inherit outline-1 :height 1.25))))
  (org-level-2        ((t (:inherit outline-2 :height 1.15))))
  (org-level-3        ((t (:inherit outline-3 :height 1.12))))
  (org-level-4        ((t (:inherit outline-4 :height 1.09))))
  (org-level-5        ((t (:inherit outline-5 :height 1.06))))
  :config
  (setq org-directory "~/Workspace/memorandum/org-mode")
  
  ;; :NOTE| Move our LaTeX previews to cache dir
  (let ((latex-dir (no-littering-expand-var-file-name "latex-preview/")))
    (unless (file-directory-p latex-dir)
      (mkdir latex-dir t))
    (setq org-preview-latex-image-directory latex-dir))

  ;; :NOTE| Change the aesthetics of our LaTeX previews
  (setq org-latex-preview-options
        (progn (plist-put org-format-latex-options :background "Transparent")
               (plist-put org-format-latex-options :scale 2.5)
               (plist-put org-format-latex-options :zoom 1.15)))
  :custom
  (org-fontify-quote-and-verse-blocks t)
  (org-catch-invisible-edits 'show-and-error)
  (org-cycle-separator-lines 2)
  (org-cycle-include-plain-lists 'integrate)
  (org-edit-src-auto-save-idle-delay 5)
  (org-ellipsis "…")
  (org-export-coding-system 'utf-8)
  (org-export-preserve-breaks t)
  (org-hide-emphasis-markers t)
  (org-highlight-latex-and-related '(native))
  (org-image-actual-width (truncate (* (window-pixel-width) 0.8)))
  (org-insert-heading-respect-content t)
  (org-latex-tables-centered t)
  (org-special-ctrl-a/e t)
  (org-startup-folded 'overview)
  (org-startup-indented t)
  (org-startup-with-inline-images t)
  (org-support-shift-select t)
  (org-tags-column 0)

  ;; Code blocks
  (org-confirm-babel-evaluate nil)
  (org-edit-src-content-indentation 0)
  (org-src-fontify-natively t)
  (org-src-preserve-indentation t)
  (org-src-tab-acts-natively nil))
#+end_src

Automatically render our LaTeX code-blocks.

#+begin_src emacs-lisp
(use-package org-fragtog
  :after org
  :hook (org-mode . org-fragtog-mode))
#+end_src

We also want to generate our "Table of Contents" on the fly.

#+begin_src emacs-lisp
(use-package toc-org
  :after org
  :hook (org-mode . toc-org-enable)
  :custom (toc-org-max-depth 3))
#+end_src

***** Org-Modern: A Modern Org-Mode Look

#+begin_src emacs-lisp
(use-package org-modern
  :after org
  :hook (org-mode . org-modern-mode)
  :custom-face
  (org-modern-symbol ((t (:family "DejaVu Sans"))))
  :custom
  ;; :NOTE| Settings replaced by svg-tag-mode
  (org-modern-tag nil)
  (org-modern-todo nil))
#+end_src

***** Org-Roam: A Powerful Note-Taking System

#+begin_src emacs-lisp
(use-package org-roam
  :after org
  :general
  (irkalla/comma-lead-keydef org-mode-map
    "o r"   '(:ignore t               :which-key "Org-Roam")
    "o r l" '(org-roam-buffer-toggle  :which-key "Org-Roam -> buffer")
    "o r n" '(org-roam-node-find      :which-key "Open node -> title/alias")
    "o r g" '(org-roam-graph          :which-key "Build -> show node of graph")
    "o r i" '(org-roam-node-insert    :which-key "Find node -> insert `:id` org-link")
    "o r c" '(org-roam-capture        :which-key "Open org-capture of node"))
  :custom
  (org-roam-directory (file-truename "~/org/org-roam"))
  (org-roam-completion-everywhere t)
  (org-roam-capture-templates
   `(("d" "default" plain "%?"
      :if-new (file+head
               "%<%Y%m%d%H%M%S>-${slug}.org"
               ,(let ((options '("#+options: _:{}"
                                 "#+options: ^:{}"
                                 "#+startup: latexpreview"
                                 "#+startup: entitiespretty"
                                 "#+startup: inlineimages"
                                 "#+title: ${title}")))
                  (mapconcat 'identity options "\n")))
      :unnarrowed t)))
  (org-roam-node-display-template "${title}"))
#+end_src

A GUI is desired for our Org-Roam to reduce the burden of browsing our notes.

#+begin_src emacs-lisp
(use-package org-roam-ui
  :after org-roam
  :custom
  (org-roam-ui-sync-theme t)
  (org-roam-ui-follow t)
  (org-roam-ui-update-on-save t)
  (org-roam-ui-open-on-start nil))
#+end_src

***** Org-Babel: Execution of Org SRC-blocks

#+begin_src emacs-lisp
(use-package ob
  :elpaca nil
  :after org
  :preface
  <<org-execute-action>>
  :hook (org-babel-after-execute . org-display-inline-images)
  :general (:states 'normal :keymaps 'org-mode-map
             "RET" '(irkalla/org-execute-action :which-key "Execute appropriate Org action"))
  :custom
  (org-babel-default-header-args
   '((:async   . "yes")
     (:cache   . "no")
     (:eval    . "never-export")
     (:exports . "code")
     (:hlines  . "no")
     (:noweb   . "yes")
     (:results . "replace")
     (:session . "none")
     (:tangle  . "no")))
  (org-export-use-babel nil)
  (org-confirm-babel-evaluate nil)
  :config
  (defadvice org-babel-execute-src-block (around load-language nil activate)
   "Load Org-babel languages on demand."
   (let ((language (org-element-property :language (org-element-at-point))))
     (unless (cdr (assoc (intern language) org-babel-load-languages))
       (add-to-list 'org-babel-load-languages (cons (intern language) t))
       (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
     ad-do-it)))
#+end_src

#+NAME: org-execute-action
#+begin_src emacs-lisp :tangle no
(defun irkalla/org-execute-action ()
  "Execute the appropriate action based on the given context."
  (interactive)
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      (`src-block
       ;; In a source block, call `org-babel-execute-src-block'.
       (org-babel-eval-wipe-error-buffer)
       (org-babel-execute-src-block current-prefix-arg))
      (`babel-call
       ;; In a `:+CALL:' block, call `org-babel-execute-maybe'.
       (call-interactively #'org-babel-execute-maybe))
      (`table-row
       ;; In a table or table-cell, call `org-table-next-row'.
       (call-interactively #'org-table-next-row))
      ((or `link `timestamp)
       ;; On a link or a timestamp, call `org-open-at-point'.
       (call-interactively #'org-open-at-point))
      (_
       ;; Fallback to evil standard command
       (call-interactively #'evil-ret)))))
#+end_src

**** Python: Boring High-level GP Language

#+begin_src emacs-lisp
(use-package python-mode
  :mode ("\\.py\\'" . python-mode)
  :hook (python-mode . eglot-ensure)
  :flymake-hook
  (python-mode flymake-collection-mypy
               flymake-collection-ruff))
#+end_src

**** Rust: A Type-safe GP Language

#+begin_src emacs-lisp
(use-package rust-mode
  :mode ("\\.rs$" . rust-mode)
  :preface
  (defun irkalla/locate-cargo-toml (dir)
    "Locate the missing Rust project Cargo.toml."
    (if-let ((root (locate-dominating-file dir "Cargo.toml")))
        (list 'vc 'Git root)))
  :hook (rust-mode . (lambda ()
                       (eglot-ensure)
                       (indent-tabs-mode -1)
                       (add-to-list 'project-find-functions #'irkalla/locate-cargo-toml)))
  :general
  (irkalla/comma-lead-keydef rust-mode-map
    "r"   '(:ignore t       :which-key "Rust")
    "r b" '(rust-compile    :which-key "Compile project")
    "r c" '(rust-check      :which-key "Compile + cargo check")
    "r l" '(rust-run-clippy :which-key "Run cargo clippy")
    "r r" '(rust-run        :which-key "Run project")
    "r t" '(rust-test       :which-key "Run tests on project"))
  :config
  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 `((rust-ts-mode rust-mode)
                   . ("rust-analyzer"
                      ;; https://rust-analyzer.github.io/manual.html
                      :initializationOptions
                      (:cargo       (:features "all")
                       :completion  (;; Completion-related
                                     :callable (:snippets "fill_arguments"))
                       :checkOnSave (;; Actions to check upon saving
                                     :command "clippy"
                                     :allTargets :json-false)))))))
#+end_src

Integrating =Cargo= with our newly added =Rust-Mode= would help us make our environment more lively!

#+begin_src emacs-lisp
(use-package cargo
  :hook (rust-mode . cargo-minor-mode)
  :general
  (irkalla/comma-lead-keydef rust-mode-map
    "r p"   '(:ignore t           :which-key "Cargo")
    "r p a" '(cargo-process-add   :which-key "Cargo Add")
    "r p c" '(cargo-process-clean :which-key "Cargo Clean"))
  :custom (cargo-process--command-clippy "clippy"))
#+end_src

Being able to retain our notes in ~Org-Mode~ would've been wonderful. Therefore we ought to make it possible!

#+begin_src emacs-lisp
(use-package ob-rust
  :after ob)
#+end_src

**** Typst: The Modern & Cleaner LaTeX

#+begin_src emacs-lisp
(use-package typst-mode
  :elpaca (:host github :repo "Ziqi-Yang/typst-mode.el")
  :mode ("\\.typ\\'" . typst-mode))
#+end_src

**** Yuck: Elkowar's Lisp Dialect for EWW (disabled)

#+begin_src emacs-lisp :tangle no
(use-package yuck-mode)
#+end_src

** Part 3: Concluding Our Emacs Journey

#+begin_src emacs-lisp
;;; init.el ends here
#+end_src
